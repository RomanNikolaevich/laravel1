#Рабочий вариант установки Laravel:
curl -s "https://laravel.build/example-app?with=mysql,redis" | bash

Проблемы при первой установке:
#1) После установки Laravel появилася варнинг:
WARNING: The WWWGROUP variable is not set. Defaulting to a blank string.
WARNING: The WWWUSER variable is not set. Defaulting to a blank string.
#Лечится он добавлением строчек в файл .env и в .env.example:
WWWGROUP=1000
WWWUSER=1000
#2)Столкнулся с проблемой миграции:
1)Выдает ошибку:
Illuminate\Database\QueryException
SQLSTATE[HY000] [2002] No such file or directory (SQL: select * from information_schema.tables where table_schema =
laravel_lessons and table_name = migrations and table_type = 'BASE TABLE')
2)Для решения в php.ini раскоментил сточку:  extension=pdo_mysql НЕ помогло, стало ругаться еще и на
"PHP Startup: Unable to load dynamic library 'pdo_mysql' ...."  - отменил
3)Через IDE установил драйвер mysqli, тоже не помогло.
4) Советовали еще вот это, тоже не помогло, установилось что-то но миграции не заработали:
sudo apt-get install -y php-pdo-mysql
5) Советовали использовать sail artisan migrate вместо php artisan migrate но это тоже не помогло
6) Все решилось очень просто - изменил в файле.env строчку DB_HOST=mysql  на DB_HOST=127.0.0.1
   Эти проблемы были вызвоны, потому что нужно было запускать сервере через sail up -d

#Пинг локального соединения:
ping localhost


#Запуск контейнеров Docker через Sail:
В файл ~/.bashrc добавить строчку: alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
Дальше запускаем в терминале только так: sail up -d
Остановить: sail stop

#Устранение ошиьки роутеров через чистку кеша:
sail artisan route:cache


Урок №1 Установка, Настройка
#Список команд artisan:
php artisan

В моем проекте добавляем сначала только 3 страницы(13:00):
1) все товары,
2) категории,
3) страницу какого-то отдельного товара

#Для смены главной страницы после установки нужно перейти в файл настройки роутера: файл routes/web.php
#Аргументом функции view() в файле web.php является название шаблона из resourses/view/welcome.plade.php
#Для изменения аргумента в роутере копируем роутер, прописываем новый аргумент test1 и создаем новый файл
resourses/view/test1.plade.php


Урок №2 Роутинг, Контроллеры
#В прошлом уроке мы добавляли статичные страницы через функцию замыкания, но это плохая практика, так как лучше
создавать классы контроллера и переносить все действия туда. Действия - это экшены. Контроллери - это обычный класс php,
для его создания воспользеумся артисаном:
php artisan make:controller MainController
После этой команды создастся класс: /app/Http/Controllers/MainController.php

#Столкнулся с ошибкой "Class "DOMDocument" not found". Решенние нашел установить компонент DOM:
sudo apt-get install php-dom


Урок №3 Работа с БД: Миграции, Модели
#Для того, чтобы мы могли изменения в БД держать в GIT, и чтобы другие их могли использовать мы будем держать
в классах.
Примеры миграций расположены в папке: database/migration
#Это обычные классы с методами up(запуск миграции) и down(откат миграции)

#Миграция:
php artisan migrate
php artisan migrate:rollback (откат миграции)

#Есть такое правило, что каждый раз когда вы делаете какие-то изменения в БД вам нужно будет создавать новую миграцию.
Ни в коем случае не трогая старую, если она уже в GIT, то есть если вы ее закомитили, то вы ее уже не трогаете.

#Создание новой заготовки миграции для продуктов:
php artisan make:migration create_products_table
php artisan migrate

#Теперь нам нужно создать новый класс, новая модель product(app/Models/Product.php]):
php artisan make:model Product

#Теперь нам нужно создать еще класс-модель и миграцию Category. Это можно сделать одной командой добавив флаг -m:
php artisan make:model -m Category

#Отменяем миграции - лектор что-то забыл:
php artisan migrate:rollback

#В миграции product и category выставляем поля:
$table->id();
$table->string('name');
$table->string('code');
$table->text('description')->nullable(); //возможно товар будет без описания
$table->text('image')->nullable(); //возможно товар будет без описания
$table->double('price')->default(0);//по умилчанию цена ноль
$table->timestamps();
В product добавляем еще строчку:
$table->integer('category_id');

#Дальше в таблице зполняем категории товаров, их названия, коды и описание.

#B MainController в метод category добавляем строчку:
Category::where('code', $category)->first();

#Выводим название категории в коде category.blade.php:
<h1>{{$category->name}}</h1>


Урок №4 Мастер шаблон
#Делаем мастершаблон master.blade.php - переносим общие для всех шаблонов части html из index.blade.php

#В файле master.blade.php прописываем то что будем вставлять (основная часть страницы, которая будет различна):
@yield('content')

#В остальных шаблонах blade прописываем с первой строчки (во всех шаблонах, кроме master):
@extends('master')
@section('content')
//контент страницы
@endsection

#Добавляем секцию заглавий для category.blade.php (без @endsection) - для каждого шаблона свой тайтл:
@section('title', 'Категория '.$category->name)
В master.blade.php в тафтл добавим ссылку:
<title>Интернет Магазин: @yield('title')</title>

#В @extends('') мы можем через запятую добавлять название для каждого шаблона:
@extends('master', ['file'=>'index'])
После чего мы можем это использовать в мастер-шаблоне через переменную {{$file}}:
<a class="navbar-brand" href="/">Интернет Магазин - {{ $file ?? '' }}</a>
В нашем проекте это не нужно, но это может в дальнейшем пригодится, а пока удаляем у себя.

#Выносим отдельно карточку товара(07:50)
#Создаем файл card.blade.php туда выносим с index.blade.php html код одного блока одного товара, а в index.blade.php,
category.blade.php все товары удаляем, а их подтягиваем через @include('card'). Дальше в скобках можно добавить массив
с переменной ['product'=>$product], но ее пока нет, поэтому добавлять не будем.

#Если у нас изменятся категории, то придется в шаблоне categories.blade.php вносить изменения, а это не очень удобно,
так как это нужно делать желательно только в роутере.  Поэтому дорабатываем наш роутер(web.php) (10:00)  так в каждой
строчке добавляем имена:
Route::get('/', [MainController::class, 'index']);
Route::get('/', [MainController::class, 'index'])->name('index');

#Добавляем шаблон карзины: /resourses/viwe/basket.blade.php (11:00):
@extends('master')
@section('title', 'Корзина')
@section('content')
//код из блока корзины
@endsection

#Добавляем в роутер web.php еще роут корзины:
Route::get('/basket', [MainController::class, 'basket'])->name('basket');

#Так же добавляем в класс MainController метод(экшин):
public function basket():Factory|View|Application
{
return view('basket');
}


#Так же делаем возможность подтвердить заказ в корзине "Подтвердите заказ": /basket/place (12:20).
Создаем order.blade.php, создаем  еще маршрут и вносим изменения в класс MainController.
Route::get('/basket/place', [MainController::class, 'basketPlace'])->name('basket-place');

    public function basketPlace():Factory|View|Application
    {
        return view('order');
    }

#Теперь у нас 6 маршрутов, но как их посмотреть если маршрутов не 6, а гораздо больше? (14:00) (в уроке используется
локальный php, а мы используем оболочку laravel над doker, поэтому используем только sail первым словом в команде!!!)
sail artisan route:list

#В master.blade.php меняем ссылки вместо "/"(переход на главную) прописываем {{ route('index') }} и так далее
со всеми ссылками.

#Настраиваем категории - у каждой категории свой URI - в categories.blade.php меняем ссылку(16:50):
<a href="/{{ $category->code}}">
на:
<a href="{{route('category', $category->code)}}">

#B web.php меняем роутер продуктов с указанием категории(18:00):
Route::get('/{category}/{product?}', [MainController::class, 'product'])->name('product');
В классе MainController в методе product добавляем еще один параметр $category:
public function product($category, $product = null):Factory|View|Application
{
return view('product', ['product' => $product]); //второй вариант передачи параметров
}
В шаблоне card.blade.php изменяем ссылку на короткий адресс к корзине:
{{ route('basket') }}
В шаблон категории изменяем в @include('card') ссылку на переменную $category:
@include('card', ['category' => $category])


#В шаблоне card так же можно вывести ссылку на название категории товара:
@isset($category)
{{ $category->name }}
@endisset


Урок №5 Eloquent связи
#Добавляем товары в БД, в таблицу products. Для импорта чужой таблицы нужно в IDE в правом верхнем углу нажать на кнопку
колнсоль и выбрать Open default console. Затем в этом окне вставить запрос с INSERT, нажать на зеленый треугольник
и если нет ошибок предложит импортировать поля в новую таблицу или выбрать из чуществующих. После обновить и проверить
правильно ли внеслось.

#Добавляем все наши товары из БД на главную страницу. В классе MainController в методе index добавляем $products,
которой присваиваем значение из запроса, берем все товары Product::get (Alt+Enter - импортировать класс) и затем его
передаем в строчке return с помощью compacts:
public function index():Factory|View|Application
{
$products = Product::get();
return view('index', compact('products'));
}
Дальше мы его обрабатываем в шаблоне index.blade.php(для того чтобы быстро найти файл по названию используем двойнок
клик Shift):
@foreach($products as $product)
@include('card', compact('product'))
@endforeach
Теперь переходим в шаблон card.blade.php, где можем эту переменную продукт отобразить - название <h3>iPhone X 64GB</h3>
заменяем на:
<h3>{{ $product->name }}</h3>
Так же меняем и строчку с ценой на : <p>{{ $product->price }} ₽</p>
Теперь все товары из БД вывелись, только фото у всех осталось одно как было в шаблоне.

#Теперь нужно сделать, чтобы категория также отображалась и на главной в описании каждого товара. В БД категория
реализована через параметр 'category_id'. Чтобы не нагружать наш контроллер мы идем в нашу модель продукт
(класс App\Models\Product) и добавляем публичный метод getCategory():
public function getCategory()
{
$category = Category::where('id', $this->category_id)->get();//через where отображаем все записи
dd($category); //распечатываем переменную
}
Так же теперь используем функцию getCategory() в шаблоне card.blade.php:
{{ $product->getCategory() }}
Через dd мы видим что передался многомерный массив (Collection - коллекция), чтобы получить только один экземпляр мы
можем использовать вместо функции get() функцию first()- так мы сразу получаем категорию, с которой удобней работать:
$category = Category::where('id', $this->category_id)->first();
На самом деле будет еще удобнее, если сменить first() на find() в которой и передадим 'category_id':
$category = Category::find($this->category_id); //результат такой же
Дальше нам нужно просто вернуть, что появилось:
return Category::find($this->category_id);
И теперь в карточке товара (шаблон card) мы можем дальше использовать ->name:
 <p>{{ $product->getCategory()->name }}</p>
 Теперь в кажом товаре на главной отображается его категория, а эту конструкцию можно удалить:
        @isset($category)
             {{ $category->name }}
        @endisset

#Дальше выводим в категории только те товары, которые относятся к этой категории(04:30). Для этого переходим в
MainController, где добавляем для метода category() переменную products(как в методе index):
public function category($code): Factory|View|Application
{
$category = Category::where('code', $code)->first();
$products = Product::get();
return view('category', compact('category', 'products'));
}
И в самом представлении категория(шаблон category) вместо строчки:
@include('card', ['category' => $category])
обрабатываем как в шаблоне index(вставляем блок):
@foreach($products as $product)
@include('card', compact('product'))
@endforeach
После этого на каждой странице категории выводятся все товары (не зависимо от категории).

#Теперь будем фильтровать(05:30). Для этого в Меинконтролере в методе продукт внесем измененияв строчке:
$products = Product::get(); //выводить все продукты
$products = Product::where('category_id', $category->id)->get();//теперь выводятся только нужные!!!

#Теперь у нас все работает, но исполняется принцип единства ответственности. Наш контроллер выходит немного
перегруженным. Чтобы этого небыло мы должны использовать связи. Для этого мы переходим в модель Product, где мы
пропишем функцию категория, которая должна вернуть только одну категорию. И так как у нас есть продукт, который
относится к категории, то мы используем belongsTo(), в которой мы указываем продукт:
public function category()
{
return $this->belongsTo(Category::class);
}
Чтобы дальше эту функцию использовать мы идем в шаблон карточки и здесь мы заменяем:
{{ $product->getCategory()->name }}
на:
{{ $product->category->name }}
Если мы захотим использовать вот таким образом:
{{ $product->category()->name }}
то это будет уже Query Builder(у меня так не сработал - ошибка)
Теперь метод getCategory() можно удалить, он не нужен.

#Дальше нам нужно добавить зависимость от категории к товарам(08:22). Для этого в классе Category создаем публичный
метод products(), в котором возвращаем функцию hasMany() - связи ко многим:
public function products()
{
return $this->hasMany(Product::class);
}
Теперь нашу связь мы можем использовать в шаблоне категория, где в цикле изменяем:
@foreach($products as $product)
на: @foreach($category->products as $product)
Так как $products мы теперь не используем, то можем из MainController из метода category строчку с переменой $products
удалить, теперь этот метод будет выглядеть так:
public function category($code): Factory|View|Application
{
$category = Category::where('code', $code)->first();
return view('category', compact('category'));
}

#Выводим подсчет количества товаров в категории(10:00) используя теже самые связи - переходим в шаблон category, где
в строчку: {{$category->name}} добавляем вызов категории с встроенной функцией count():
{{$category->name}} {{$category->products->count()}}// получаем "Мобильные телефоны 4"

#Прописываем ссылку на товар в шаблоне card. Для этого изменяем нашу ссылку:
<a href="/mobiles/iphone_x_64" class="btn btn-default" role="button">Подробнее</a>
на новый роут:
<a href="{{ route('product',[$product->category->code, $product->code]) }}"
class="btn btn-default" role="button">Подробнее</a>


Урок №6 Многие-ко-многим, Сессия
#Следующее, что нам нужно сделать - реализовать корзину и заказ. Это мы будем делать через одну модель. Создаем новый
класс Order вместе с миграцией:
sail artisan make:model -m Order

#Редактируем воля в нашей миграции: /database/migration. Нам нужен, во-первых, статус, если мы хотим совместить и заказ
и корзину в одно, то нам нужно это все указать:
            $table->tinyInteger('status')->default(0);//0 - это для незаказанных товаров.
            $table->string('name')->nullable(); //данные заказчика, необязательный параметр
            $table->string('phone')->nullable(); //данные заказчика, необязательный параметр.
Запускаем миграцию:
sail artisan migrate

#Так же нам нужна связка для понимания какие продукты лежат в нашем заказе. Для этого мы создадим еще одну миграцию:
sail artisan make:migration create_order_product_table

#В этой миграции мы добавим еще два поля(кроме стандартных):
            $table->integer('order_id');
            $table->integer('product_id');
Зачем нам такая таблица нужна? Для каждого заказа у нас может быть несколько продуктов, так же каждый продукт может
 находитиься в нескольких заказах.
 Запускаем миграцию:
 sail artisan migrate

#Почему наша новая таблица называется "order_product", а не наоборот? Мы будем использовать связь, и чтобы связь
использовала название таблицы поумолчанию нам нужно название наших сущностей order и product расположить в алфавитном
 порядке.

#Добавляем связь, чтобы из заказа найти наши продукты(03:20), для этого в классе Order добавляем метод products во
множественном числе:
    public function products()
    {
        return $this->belongsToMany(Product::class);
    }
По-идее она должна подхватить таблицу "order_product" - через 'order_id' и 'product_id' составить соотношение.

#Так же нам нужно бы уже создать новый маршрут, который будет отвечать за то, чтобы положить какой-то продукт в корзину.
Создаем новый контроллер:
    sail artisan make:controller BasketController
Убираем из MainController методы basket() и basketPlace() в новый класс BasketController.
Добавляем так же информацию в роутер web.php:
    Route::get('/basket', [MainController::class, 'basket'])->name('basket');
    Route::get('/basket/place', [MainController::class, 'basketPlace'])->name('basket-place');
меняем на:
    Route::get('/basket', [BasketController::class, 'basket'])->name('basket');
    Route::get('/basket/place', [BasketController::class, 'basketPlace'])->name('basket-place');

#Дальше нам нужно сделать маршрут, который будет отвечать за добавление товара(05:00) в web.php методом POST, так как
все что мы изменяем мы испольуем метод POST(http метод):
Route::post('/basket/add/{id}', [BasketController::class, 'basketAdd'])->name('basket-add'); //id - идентификатор продукта

#Чтобы воспользоваться этим методом мы идем в карточку товара(card) и делаем из ссылки форму:
    <form action="{{ route('basket-add', $product) }}" method="POST">...
Идентификатор у переменной продукт можно не указывать($product->id).

#Пробуем добавить товар в корзину - выдает 419 ошибку(используется в качестве альтернативы коду 401, которые прошли проверку
 подлинности, но лишены доступа к определенным ресурсам сервера. Обычно код отдается, если CSRF-токен устарел или оказался
 некорректным.). Для того, чтобы убрать эту ошибку, нужно добавить csrf-токен(под токеном имеется в виду случайный набор
 байт, который сервер передает клиенту, а клиент возвращает серверу).Чтобы его добавить мы можем воспользоваться директивой
 блейда
    @csrf
эта команда генерирует скрытый инпут со случайным токеном, такого образца:
    <input type="hidden" name="_token" value="A6RKV8btdJu2SrcengeSw9JserC4AVdI9iX0TPxS">

#Теперь нам осталось добавить еще один метод, котрый будет отвечать за добавление товаров в корзину в классе BasketController.
Для того чтобы добавлять товары нам нужна сессия - в Laravel ее создает встроенный хелпер session(). А для того, чтобы
достать что-то из сессии мы будем использовать аргумент 'orderId':
    public function basketAdd($productId)
    {
        $orderId = session('orderId');
        if (is_null($orderId)) { //если нет сессии создаем ее
            $order = Order::create()->id;
            session(['orderId' => $order->id]);
        } else {
            $order = Order::find($orderId); //если есть находим
        }
        $order->products()->attach($productId); //добавляем товар в корзину, используем нашу связь.

        return view('basket', compact('order'));
    }
Проверяем в базе товары появляются при нажатии на корзину.
Вносим изменения так же в метод basket():
    public function basket():Factory|View|Application
    {
        $orderId = session('orderId');
        if (!is_null($orderId)) {
        $order = Order::findOfFail($orderId);
        }
        return view('basket');
    }

#Теперь нам нужно перейти в представление/шаблон basket.blade.php и добавить обработку наших товаров:
    @foreach($order->products as $product)
        //сюда размещаем блок товара
    @endforeach

#В роутере web.php строчка роутером 'basket' должна быть выше расположена, чем роутер 'category'!!! Иначе ошибка.

#Добавляем роут к правильным ссылкам в корзине:
 <a href="{{ route('product', [$product->category->code, $product->code]) }}">
так же заменяем ссылку:
    /basket/add/1
на:
    <form action="{{ route('basket-add', $product) }}" method="POST">
добавляем @csrf токен


Урок №7 Pivot table
#Добавляем маршрут для удаления товаров из корзины. Добавляем роут в web.php:
Route::post('/basket/remove/{id}', [BasketController::class, 'basketRemove'])->name('basket-remove');

#Изменяем роут в basket.blade.php:
    <form action="{{ route('basket-remove', $product) }}" method="POST">
        <button type="submit" class="btn btn-danger" href=""><span
                class="glyphicon glyphicon-minus" aria-hidden="true"></span></button>
        @csrf
    </form>

#В BasketController добавляем метод удаления из корзины:
    public function basketRemove($productId):RedirectResponse
    {
        $orderId = session('orderId');
        if (is_null($orderId)) {
            return redirect()->route('basket');
        }
        $order = Order::find($orderId);
        $order->products()->detach($productId);//удалям продукт
        return redirect()->route('basket');
    }

#Чтобы при обновлении страницы не добавляло новый товар - в функцию basketAdd добавим редирект на другой маршрут:
return redirect()->route('basket');
А эту строчку удаляем:
return view('basket', compact('order'));

#Теперь нам нужно реализовать количество добавляемого товара, чтобы не новой строчкой одинаковый товар добавлялся,
а изменялась цифра-количество товаров. Для этого нам нужно добавить миграцию (добавим еще одно поле в таблицу через
update). Миграция с таким же именем уже была создана ранее, записана в таблицу и если ее откатить для внесения изменений,
то мы потеряем в таблице все наши данные.
sail artisan make:migration update_order_product_table
Далее копируем из предыдущей миграци с таким же именем поля метода up():
     Schema::table('order_product', function (Blueprint $table) { //только вместо Schema::table...
         $table->integer('count')->default(1); //добавляем новое поле
     });
И в методе down() добавляем:
    Schema::table('order_product', function (Blueprint $table) {
        $table->dropColumn('count');
    });
#Запускаем миграцию:
    sail artisan migrate
После этого замечаем, что лучше было бы указать место расположения нового поля:
    $table->integer('count')->default(1)->after('product_id');
Для внесения изменений в таблице нам придется откатить последнее изменение:
    sail artisan migrate:rollback --step=1
Затем снова миграцию делаем:
    sail artisan migrate

#Теперь нам нужно этот count заставить работать. Для этого в Order.php добавляем возможность достучаться до поля count:
    return $this->belongsToMany(Product::class)->withPivot('count');

#Теперь нужно к контиролере корзины добавить при добавлении проверку если у нас уже такой товар:
        if ($order->products->contains($productId)) {//если товар есть в корзине:
            $pivotRow = $order->products()->where('product_id', $productId)->first()->pivot;
            $pivotRow->count++;//увеличивает attributes-count на 1
            $pivotRow->update();//обновляем в БД
            dd($pivotRow);//проверка вывода
        } else {//если товара нет в корзине:
            $order->products()->attach($productId); //добавляем товар в корзину, используем нашу связь.
        }

#Теперь нам то же самое нужно проделать с удалением товара:
        if ($order->products->contains($productId)) {
            $pivotRow = $order->products()->where('product_id', $productId)->first()->pivot;
            if ($pivotRow->count < 2) { //если 1 или 0
                $order->products()->detach($productId);//удалям продукт
            } else {
                $pivotRow->count--;//уменьшаем attributes-count на 1
                $pivotRow->update();//обновляем в БД
            }
        }

#В шаблон basket добавляем отображение изменения количчества товаров (из БД) (13:15):
    {{ $product->pivot->count }}

#Добавляем общую сумму покупок. Для этого в классе Product добавляем новый метод:
    public function getPriceCount($count)
    {
        return $this->price * $count;
    }
Добавляем вывод в шаблон корзины - вместо:
    {{ $product->price }}
Пишем:
    {{ $product->getPriceCount($product->pivot->count) }}

#Добавляем подсчет стоимости всех товаров в корзине, для этого в классе Order.php добавляем метод:
    public function getFullPrice():int | float
    {
        $sum = 0;
        foreach ($this->products as $product) {
            $sum += $product->getPriceForCount();
        }
        return $sum;
    }

#Выводим общую сумму в basket.blade.php:
{{ $order->getFullPrice()}}

Урок №8 Request, Flash

#Доделываем нашу корзину заказов и делаем, чтобы заказ был полностью оформлен.

#Добавляем переход на страницу заказа. Для этого из роутера (web.php) берем basket-place и прописываем путь в basket.blade.php
вместо href="/basket/place"> прописываем  роут:
href="{{ route('basket-place') }}"

#В order.blade.php не верно выводится общая сумма - нужно поправить. Для этого переходим в BasketController и правим метод
basketPlace():
    public function basketPlace()
    {
        $orderId = session('orderId');
        if (is_null($orderId)) {
            return redirect()->route('index'); //возвращаем на главную
        }
        $order = Order::find($orderId);
        return view('order', compact('order'));
    }
И в order.blade.php добавляем общую цену:
{{ $order->getFullPrice()}} грн.

#Теперь нам нужно, чтобы эта кнопка вела туда, где будет сохранен наш заказ. В web.php добавляем еще один роут:
Route::post('/basket/place', [BasketController::class, 'basketConfirm'])->name('basket-confirm');

#В order.blade.php добавляем роут в экшин формы:
<form action="{{ route('basket-confirm') }}" method="POST">

#Добавляем @csrf токен в форму перед кнопкой

#B BasketController теперь нужно реализовать новый метод из web.php basketConfirm():
    public function basketConfirm()
    {

    }
При переходе по кнопке "Подтвердите заказ" страница одновляется, но получаем пустую страницу, так как метод еще не реализован.

#В папке с шаблонами (/resourses/views) нужно навести порядок и сложить некоторые швблоны в новую подпапку layouts,
после туда перемещаем master.blade.php, card.blade.php

#В product.blade.php так же часто повторяется блок <div class="starter-template">, поэтому мы его тоже вынесем в
master.blade.php:
    <div class="starter-template">
        @yield('content')
    </div>
И в каждом из шаблонов соответственно этот блок нужно убрать, чтобы небыло дублей.

#Добавляем логику сохранения в БД в метод basketConfirm():
    public function basketConfirm(Request $request):RedirectResponse
    {
        $orderId = session('orderId');
        if (is_null($orderId)) { //если нет сессии создаем ее
            return redirect()->route('index'); //возвращаем на главную
        }
        $order = Order::find($orderId); //если есть находим
        $order->name = $request->name;
        $order->phone = $request->phone;
        $order->status = 1; //изменяем статус в БД с 0 до 1
        $order->save();
        //dd($request->all());//выводит всю информацию о заказчике
        //dd($request->name);//выводит ФИО заказчика
        session()->forget('orderId');//убираем из сессии и передаем ключ, по которому должен забыть переменную
        return redirect()->route('index'); //возвращаем на главную
    }
Теперь если нажимаем подтвердить заказ - в таблице 'orders' у заказа появляется статус и данные о заказчике.

#Все работает, но нужна оптимизация - слишком много логики для контролера, поэтому часть кода переносим в модель
в класс Order заменив переменную $order на $this, с реквестом мы тоже тут не будем работать, поэтому в метод передадим
имя и телефон:
    public function saveOrder($name, $phone)
    {
        if ($this->status == 0) {
            $this->name = $name;
            $this->phone = $phone;
            $this->status = 1; //изменяем статус в БД с 0 до 1
            $this->save();
            session()->forget('orderId');//убираем из сессии и передаем ключ, по которому должен забыть переменную
            return true;
        } else {
            return false;
        }
    }

BasketController теперь станет немного чище:
    public function basketConfirm(Request $request):RedirectResponse
    {
        $orderId = session('orderId');
        if (is_null($orderId)) { //если нет сессии создаем ее
            return redirect()->route('index'); //возвращаем на главную
        }
        $order = Order::find($orderId); //если есть находим
        $success = $order->saveOrder($request->name, $request->phone);
        return redirect()->route('index'); //возвращаем на главную
    }

#Функционал сообщенией "Ваше товар добавлен в корзину", "Ваш заказа отправлен в обработку" реализован с помощью
 Flash(13:30). То есть это часть функционала сессии, такие переменные внутри сессии, которые после первого отображения
 позволяет их автоматически удалять. Флеш в Laravel реализован с помощью функции flash() - в BasketController добавим:
        if ($success) {
            session()->flash('success', 'Ваш заказ принят в обработку');
        } else {
            session()->flash('warning', 'Случилась ошибка');
        }

#Для отображения вывода flash добавления (зеленая расцветка)переходим в master.blade.php:
        @if(session()->has('success'))// условие для вывода flash сообщения
        <p class="alert alert-success">{{ session()->get('success') }}</p>// вывод flash сообщения
        @endif
        @yield('content')

#В BasketController в методе basketAdd() добавим отображение сообщения об добавлении товара в корзину:
        $product = Product::find($productId);//находим товар
        session()->flash('success', 'Добавлен товар '. $product->name);

#Для отображения вывода flash удаления (желтая расцветка)переходим в master.blade.php:
        @if(session()->has('warning'))
            <p class="alert alert-warning">{{ session()->get('warning') }}</p>
        @endif

#В BasketController в методе basketRemove() добавляем сообщение об удалении товара из корзины:
        $product = Product::find($productId);//находим товар
        session()->flash('warning', 'Удален товар '. $product->name);


Урок №9 Авторизация, Регистрация

#Добаление административной панели.

#В уроках используется Laravel 6 и там аутентификация встроена, для поздних версий (у меня 9я) нужно устанавливать:
composer require laravel/ui

#У меня сразу не получилось установить выдало ошибку. Помогло вот это:
    > sudo apt-get install php-curl
    > sudo apt-get install php-mbstring
#for every missing extension. Then:
    > sudo apt-get update
#and finally (in the project's root folder):
    > composer install

Дальше:
    composer require laravel/ui
    composer dump-autoload
    sail artisan optimize
    sail artisan ui:auth
Теперь в /app/Http/Controllers/Auth папка с файлами появилась, как в уроке.
Дальше создаем шаблоны авторизации:
    sail artisan ui vue --auth


#После установки в web.php появился новый роут:
    Auth::routes();
    Route::get('/home', [App\Http\Controllers\HomeController::class, 'index'])->name('home');
в web.php в самый вверх прописать:
    use Illuminate\Support\Facades\Auth;

#Чтобы посмотреть, что нового добавилось нужно ввести(покажет новые маршруты):
    sail artisan route:list

#Как посмотреть какие маршруты у нас зарегистрированы - переходим к файлу Router.php(Shift два раза кликнуть), таких
файла два, выбираем того, что для Laravel.

#В web.php добавляем строчки (обрезаем неиспользуемые параметры):
Auth::routes([
    'reset' => false,
    'confirm' => false,
    'verify' => false,
]);

#В папку /resources/view/auth добавляем файлы login.blade.php, register.blade.php, а содержание берем из html
кода оригинального сайта.

#Название для шаблонов берем из трейтов AuthenticatesUsers ('login') и RegistersUsers ('register')

#Добавляем /layouts/master.blade.php  - шаблон для аутентификации, чтобы не повторялись поля в коде.
меняем: <title>Админка: Регистрация</title>
на: <title>Админка: @yield('title')</title>
меняем: <div class="card-header">Регистрация</div>
на: @yield('title')
Удаляем уникальные для разных страниц блоки, остается общий шаблон. Вместо уникального контента пишем:
@yield('content')

#В login.blade.php, register.blade.php оставляем только уникальный контент между скриптом:
@extends('auth.layouts.master')//расположение master шаблона
@section('title', 'Авторизация')//или 'Регистрация'
    @section('content')
        //форма регистрации/логина
    @endsection

#Добавляем роуты в master.blade.php:
<a class="nav-link" href="{{ route('login') }}">Войти</a>
<a class="nav-link" href="{{ route('register') }}">Зарегистрироваться</a>

В шаблон register:
<form method="POST" action="{{ route('register') }}" aria-label="Register">

#В роутер добавляем :
    use App\Http\Controllers\Auth\LoginController;
прописываем путь и назначаем имя как будем называть:
    Route::get('/logout', [LoginController::class, 'logout'])->name('get-logout');

#В основной мастер шаблон добавляем в верхнее меню ссылку входа/выхода:
    @guest()
        <li><a href="{{ route('login') }}">Панель администратора</a></li>
    @endguest
    @auth()
            <li><a href="{{ route('home') }}">Панель администратора</a></li>
        <li><a href="{{ route('get-logout') }}">Выйти</a></li>
    @endauth

#Добавим новый контроллер(12:20): //он у нас уже создался ранее
sail artisan make:Controller HomeController

#B web.php добавляем маршрут:
Route::get('/home', [HomeController::class, 'index'])->name('home');


Урок №10 Middleware Авторизации

#web.php добавляем middleware(это прослойка между маршрутом и контроллером)
Route::get('/home', [HomeController::class, 'index'])->name('home')->middleware('auth');

#Для каждого маршрута добавлять проверку не очень удобно, поэтому есть способ через Route::group
Route::group(['middleware' => 'auth'], function () {
    Route::get('/home', [HomeController::class, 'index'])->name('home');
});

#Добавляем страницу заказов в админке - создаем шаблон resources/viewes/auth/orders/index.blade.php
ДОбавляем уникальный html код. Добавляем функционал из мастершаблона.

#B HomeController добавляем маршрут к админке:
class HomeController extends Controller
{
    public function index():Factory|View|Application
    {
        return view('auth.orders.index');
    }
}

#Правим наш register.blade.php, master.blade.php

#B web.php /home меняем на /orders

#HomeController меняем на OrderController через Shift+F6 (после чего везде меняется название)

#Добавляем новый метод в LoginController:
    protected function redirectTo():string
    {
        return route('home');
    }

#Проверка роута: (15:30)
php artisan route:list
Смотрим, что register осуществляет POST Auth\RegisterController@register, переходим в него и видим там свойство $redirectTo
Добавляем в этом контролере новый метод с таким же названием redirectTo():
    protected function redirectTo()
    {
        return route('home');
    }
А protected $redirectTo = RouteServiceProvider::HOME; удаляем

#OrderController.php переносим в новосозданную папку Admin, так как так логичнее. После переноса проверяем, чтобы в
неймспейсах прописалась новая папка. Так же проверяем, чтобы неймспес сменился у этого контролера и в web.php
В метод index добавляем строку:
        $orders = Order::where('status', 1)->get();
        return view('auth.orders.index', compact('orders'));

B index.blade.php отображаем:
            @foreach($orders as $order)
                <tr>
                    <td>{{ $order->id}}</td>
                    <td>{{ $order->name }}</td>
                    <td>{{ $order->phone }}</td>
                    <td>{{ $order->created_at->format('H:i d/m/Y') }}</td>
                    <td>{{ $order->getFullPrice() }} руб.</td>
                    <td>
                        <div class="btn-group" role="group">
                            <a class="btn btn-success" type="button"
                               href="http://laravel-diplom-1.rdavydov.ru/admin/orders/1">Открыть</a>
                        </div>
                    </td>
                </tr>
            @endforeach


#

Урок №11 Создание Middleware, Auth

#На данный момент в админке у нас любой зарегистрировавшийся пользователь может попасть в админку и видеть все заказы.
Для этого мы создадим новое поле в таблице 'users':
sail artisan make:migration alter_table_users

#В новой миграции добавляем поле 'is_admin'. Методы копируем из предыдущей миграции, меняем только название таблицы,
 название и свойства полей:
    public function up():void
    {
        Schema::table('users', function (Blueprint $table) {
            $table->tinyInteger('is_admin')->default(0);
        });
    }
    public function down():void //это метод для отката миграции
    {
        Schema::table('users', function (Blueprint $table) {
            $table->dropColumn('is_admin');
        });
    }
Запускаем миграцию:
    sail artisan migrate

#Переходим в талицу и в поле 'is_admin' вручную добавляем "1" тем email, кого хотим видеть адимнистратором.

#Теперь нам нужно это как-то проверять и фильтровать. Для этого добавим Middleware. Делаем через:
    sail artisan make:
появляется подсказка и оттуда подсматриваем + добавляем название и запускаем:
    sail artisan make:middleware ChackIsAdmin
У нас появился новый класс ChackIsAdmin
    public function handle(Request $request, Closure $next)
    {
        return $next($request);
    }
Модифицируем его - если пользователь не админ, то он должен редиректиться на главную страницу. Для этого нам нужно создать
новую функцию в классе User:
    public function isAdmin()
    {
        return $this->is_admin === 1;
    }

#В Kernel.php добавляем
protected $routeMiddleware = [
...
        'is_admin' => \App\Http\Middleware\ChackIsAdmin::class,

Дальше нам нужно вот этот алиас использовать внутри роутинга(web.php):
вместо :
    Route::get('/orders', [OrderController::class, 'index'])->name('home');
прописываем:
    Route::group(['middleware' => 'is_admin'], function () {
        Route::get('/orders', [OrderController::class, 'index'])->name('home');
    });

#Теперь в ChackIsAdmin проверим что мы туда попадаем добавив: dd(1);
Должно вывести 1 при переходе в /routers, но у меня ничего не произошло, поэтому чистим кеш:
    sail artisan route:cache
Теперь все работает. Вместо dd добавляем фасад Auth и берем функцию user. Фасад - это некий статичный класс, который
закрывает наш функционал.
    public function handle(Request $request, Closure $next)
    {
        $user = Auth::user();
        dd($user);
        return $next($request);
    }
У нас появился объект модели user с полем 'is_admin', но тут много ненужной информации ищем только это:
     dd($user->isAdmin());
Получаем true/false. Все работает, поэтому вместо dd прописываем условие:
        if(!$user->isAdmin()){
            session()->flash('warning', 'У вас нет прав администратора'); //уведомление
            return redirect()->route('index'); //редирект если не админ на главную
        }
Меняем в БД себе права с 1 на 0 и пробуем зайти на /orders - перебрасывает на главную, все работает.

#Теперь добавить возможность отображения по кажому пользователю какие заказы он в прошлом заказывал. Для этого в таблице
'orders' добавить новое поле 'user_id':
    sail artisan make:migration alter_table_orders
Добавляем методы:
    public function up()
    {
        Schema::table('orders', function (Blueprint $table) {
            $table->integer('user_id');//по умолчанию у нас все поля not nullable
        });
    }
    public function down()
    {
        Schema::table('orders', function (Blueprint $table) {
            $table->dropColumn('user_id');
        });
    }
Запускаем миграцию:
    sail artisan migrate

#B BasketController добавляем передачу заказа в новое поле в методе basketAd():
        if (Auth::check()) {//если мы авторизованы, то:
            $order->user_id = Auth::id();//добавляем в поле 'user_id' метод id() класса Auth
            $order->save(); // сохраняем
        }

#При создани миграции мы не указали, что если пользователь если не авторизован, то у него "0". Для этого откатываем нашу
миграцию(если мы эту миграцию никуда не пушили, то можно просто менять):
    sail artisan migrate:rollback --step=1
Добавляем nullable:
    public function up()
    {
        Schema::table('orders', function (Blueprint $table) {
            $table->integer('user_id')->nullable();//по умолчанию у нас все поля not nullable
        });
    }
Затем снова делаем миграцию:
    sail artisan migrate
И пробуем добавить в корзину товар. В таблице 'orders' появилось поле 'user_id' и в нем уже проставляется id пользователя,
заказавшего этот товар.

#Теперь нужно реализовать выход из корзины, если покупатель удалил свой товар и корзина пустая, а так же сделать
не возможным заходить в пустую корзину. Это опять же мы реализуем через middleware:
    sail artisan make:middleware BasketIsNotEmpty

затем мы этот класс регистрируем в Kernel.php:
        'basket_not_empty' => \App\Http\Middleware\BasketIsNotEmpty::class,

Теперь этот middleware нужно повесить на все маршруты, которые работают с корзиной(в web.php), для этого создаем роут
и переносим в него все ранее созданные роуты, которые уже работают с корзиной:
    Route::group(['middleware' => 'basket_not_empty'], function () {
        Route::get('/basket', [BasketController::class, 'basket'])->name('basket');
        Route::get('/basket/place', [BasketController::class, 'basketPlace'])->name('basket-place');
        Route::post('/basket/add/{id}', [BasketController::class, 'basketAdd'])->name('basket-add');
        Route::post('/basket/remove/{id}', [BasketController::class, 'basketRemove'])->name('basket-remove');
        Route::post('/basket/place', [BasketController::class, 'basketConfirm'])->name('basket-confirm');
    });

Так же мы видим, что везде в роутах повторяется слово basket, поэтому мы его перенесем в group:
Route::group([
    'middleware' => 'basket_not_empty',
    'prefix' => 'basket',//теперь слово basket из роута можно удалить
], function () {
    Route::get('/', [BasketController::class, 'basket'])->name('basket');
    Route::get('/place', [BasketController::class, 'basketPlace'])->name('basket-place');
    Route::post('/add/{id}', [BasketController::class, 'basketAdd'])->name('basket-add');
    Route::post('/remove/{id}', [BasketController::class, 'basketRemove'])->name('basket-remove');
    Route::post('/place', [BasketController::class, 'basketConfirm'])->name('basket-confirm');
});
Так же повторяется название, но мы его пока не будем выносить.
Проверяем - выходим и заходим в пустую корзину, все работает как ранее, значит ничего не сломалось хотя бы.

#Проверить если в нас заказ? Для этого переходим в BasketController, копируем проверку и вставляем в BasketIsNotEmpty
и меняем значение на !is_null:



#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
