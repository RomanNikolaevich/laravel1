#Рабочий вариант установки Laravel:
curl -s "https://laravel.build/example-app?with=mysql,redis" | bash

Проблемы при первой установке:
#1) После установки Laravel появилася варнинг:
WARNING: The WWWGROUP variable is not set. Defaulting to a blank string.
WARNING: The WWWUSER variable is not set. Defaulting to a blank string.
#Лечится он добавлением строчек в файл .env и в .env.example:
WWWGROUP=1000
WWWUSER=1000
#2)Столкнулся с проблемой миграции:
1)Выдает ошибку:
Illuminate\Database\QueryException
SQLSTATE[HY000] [2002] No such file or directory (SQL: select * from information_schema.tables where table_schema =
laravel_lessons and table_name = migrations and table_type = 'BASE TABLE')
2)Для решения в php.ini раскоментил сточку:  extension=pdo_mysql НЕ помогло, стало ругаться еще и на
"PHP Startup: Unable to load dynamic library 'pdo_mysql' ...."  - отменил
3)Через IDE установил драйвер mysqli, тоже не помогло.
4) Советовали еще вот это, тоже не помогло, установилось что-то но миграции не заработали:
sudo apt-get install -y php-pdo-mysql
5) Советовали использовать sail artisan migrate вместо php artisan migrate но это тоже не помогло
6) Все решилось очень просто - изменил в файле.env строчку DB_HOST=mysql  на DB_HOST=127.0.0.1
   Эти проблемы были вызвоны, потому что нужно было запускать сервере через sail up -d

#Пинг локального соединения:
ping localhost


#Запуск контейнеров Docker через Sail:
В файл ~/.bashrc добавить строчку: alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
Дальше запускаем в терминале только так: sail up -d
Остановить: sail stop

#Устранение ошиьки роутеров через чистку кеша:
sail artisan route:cache


Урок №1 Установка, Настройка
#Список команд artisan:
php artisan

В моем проекте добавляем сначала только 3 страницы(13:00):
1) все товары,
2) категории,
3) страницу какого-то отдельного товара

#Для смены главной страницы после установки нужно перейти в файл настройки роутера: файл routes/web.php
#Аргументом функции view() в файле web.php является название шаблона из resourses/view/welcome.plade.php
#Для изменения аргумента в роутере копируем роутер, прописываем новый аргумент test1 и создаем новый файл
resourses/view/test1.plade.php


Урок №2 Роутинг, Контроллеры
#В прошлом уроке мы добавляли статичные страницы через функцию замыкания, но это плохая практика, так как лучше
создавать классы контроллера и переносить все действия туда. Действия - это экшены. Контроллери - это обычный класс php,
для его создания воспользеумся артисаном:
php artisan make:controller MainController
После этой команды создастся класс: /app/Http/Controllers/MainController.php

#Столкнулся с ошибкой "Class "DOMDocument" not found". Решенние нашел установить компонент DOM:
sudo apt-get install php-dom


Урок №3 Работа с БД: Миграции, Модели
#Для того, чтобы мы могли изменения в БД держать в GIT, и чтобы другие их могли использовать мы будем держать
в классах.
Примеры миграций расположены в папке: database/migration
#Это обычные классы с методами up(запуск миграции) и down(откат миграции)

#Миграция:
php artisan migrate
php artisan migrate:rollback (откат миграции)

#Есть такое правило, что каждый раз когда вы делаете какие-то изменения в БД вам нужно будет создавать новую миграцию.
Ни в коем случае не трогая старую, если она уже в GIT, то есть если вы ее закомитили, то вы ее уже не трогаете.

#Создание новой заготовки миграции для продуктов:
php artisan make:migration create_products_table
php artisan migrate

#Теперь нам нужно создать новый класс, новая модель product(app/Models/Product.php]):
php artisan make:model Product

#Теперь нам нужно создать еще класс-модель и миграцию Category. Это можно сделать одной командой добавив флаг -m:
php artisan make:model -m Category

#Отменяем миграции - лектор что-то забыл:
php artisan migrate:rollback

#В миграции product и category выставляем поля:
$table->id();
$table->string('name');
$table->string('code');
$table->text('description')->nullable(); //возможно товар будет без описания
$table->text('image')->nullable(); //возможно товар будет без описания
$table->double('price')->default(0);//по умилчанию цена ноль
$table->timestamps();
В product добавляем еще строчку:
$table->integer('category_id');

#Дальше в таблице зполняем категории товаров, их названия, коды и описание.

#B MainController в метод category добавляем строчку:
Category::where('code', $category)->first();

#Выводим название категории в коде category.blade.php:
<h1>{{$category->name}}</h1>


Урок №4 Мастер шаблон
#Делаем мастершаблон master.blade.php - переносим общие для всех шаблонов части html из index.blade.php

#В файле master.blade.php прописываем то что будем вставлять (основная часть страницы, которая будет различна):
@yield('content')

#В остальных шаблонах blade прописываем с первой строчки (во всех шаблонах, кроме master):
@extends('master')
@section('content')
//контент страницы
@endsection

#Добавляем секцию заглавий для category.blade.php (без @endsection) - для каждого шаблона свой тайтл:
@section('title', 'Категория '.$category->name)
В master.blade.php в тафтл добавим ссылку:
<title>Интернет Магазин: @yield('title')</title>

#В @extends('') мы можем через запятую добавлять название для каждого шаблона:
@extends('master', ['file'=>'index'])
После чего мы можем это использовать в мастер-шаблоне через переменную {{$file}}:
<a class="navbar-brand" href="/">Интернет Магазин - {{ $file ?? '' }}</a>
В нашем проекте это не нужно, но это может в дальнейшем пригодится, а пока удаляем у себя.

#Выносим отдельно карточку товара(07:50)
#Создаем файл card.blade.php туда выносим с index.blade.php html код одного блока одного товара, а в index.blade.php,
category.blade.php все товары удаляем, а их подтягиваем через @include('card'). Дальше в скобках можно добавить массив
с переменной ['product'=>$product], но ее пока нет, поэтому добавлять не будем.

#Если у нас изменятся категории, то придется в шаблоне categories.blade.php вносить изменения, а это не очень удобно,
так как это нужно делать желательно только в роутере.  Поэтому дорабатываем наш роутер(web.php) (10:00)  так в каждой
строчке добавляем имена:
Route::get('/', [MainController::class, 'index']);
Route::get('/', [MainController::class, 'index'])->name('index');

#Добавляем шаблон карзины: /resourses/viwe/basket.blade.php (11:00):
@extends('master')
@section('title', 'Корзина')
@section('content')
//код из блока корзины
@endsection

#Добавляем в роутер web.php еще роут корзины:
Route::get('/basket', [MainController::class, 'basket'])->name('basket');

#Так же добавляем в класс MainController метод(экшин):
public function basket():Factory|View|Application
{
return view('basket');
}


#Так же делаем возможность подтвердить заказ в корзине "Подтвердите заказ": /basket/place (12:20).
Создаем order.blade.php, создаем  еще маршрут и вносим изменения в класс MainController.
Route::get('/basket/place', [MainController::class, 'basketPlace'])->name('basket-place');

    public function basketPlace():Factory|View|Application
    {
        return view('order');
    }

#Теперь у нас 6 маршрутов, но как их посмотреть если маршрутов не 6, а гораздо больше? (14:00) (в уроке используется
локальный php, а мы используем оболочку laravel над doker, поэтому используем только sail первым словом в команде!!!)
sail artisan route:list

#В master.blade.php меняем ссылки вместо "/"(переход на главную) прописываем {{ route('index') }} и так далее
со всеми ссылками.

#Настраиваем категории - у каждой категории свой URI - в categories.blade.php меняем ссылку(16:50):
<a href="/{{ $category->code}}">
на:
<a href="{{route('category', $category->code)}}">

#B web.php меняем роутер продуктов с указанием категории(18:00):
Route::get('/{category}/{product?}', [MainController::class, 'product'])->name('product');
В классе MainController в методе product добавляем еще один параметр $category:
public function product($category, $product = null):Factory|View|Application
{
return view('product', ['product' => $product]); //второй вариант передачи параметров
}
В шаблоне card.blade.php изменяем ссылку на короткий адресс к корзине:
{{ route('basket') }}
В шаблон категории изменяем в @include('card') ссылку на переменную $category:
@include('card', ['category' => $category])


#В шаблоне card так же можно вывести ссылку на название категории товара:
@isset($category)
{{ $category->name }}
@endisset


Урок №5 Eloquent связи
#Добавляем товары в БД, в таблицу products. Для импорта чужой таблицы нужно в IDE в правом верхнем углу нажать на кнопку
колнсоль и выбрать Open default console. Затем в этом окне вставить запрос с INSERT, нажать на зеленый треугольник
и если нет ошибок предложит импортировать поля в новую таблицу или выбрать из чуществующих. После обновить и проверить
правильно ли внеслось.

#Добавляем все наши товары из БД на главную страницу. В классе MainController в методе index добавляем $products,
которой присваиваем значение из запроса, берем все товары Product::get (Alt+Enter - импортировать класс) и затем его
передаем в строчке return с помощью compacts:
public function index():Factory|View|Application
{
$products = Product::get();
return view('index', compact('products'));
}
Дальше мы его обрабатываем в шаблоне index.blade.php(для того чтобы быстро найти файл по названию используем двойнок
клик Shift):
@foreach($products as $product)
@include('card', compact('product'))
@endforeach
Теперь переходим в шаблон card.blade.php, где можем эту переменную продукт отобразить - название <h3>iPhone X 64GB</h3>
заменяем на:
<h3>{{ $product->name }}</h3>
Так же меняем и строчку с ценой на : <p>{{ $product->price }} ₴</p>
Теперь все товары из БД вывелись, только фото у всех осталось одно как было в шаблоне.

#Теперь нужно сделать, чтобы категория также отображалась и на главной в описании каждого товара. В БД категория
реализована через параметр 'category_id'. Чтобы не нагружать наш контроллер мы идем в нашу модель продукт
(класс App\Models\Product) и добавляем публичный метод getCategory():
public function getCategory()
{
$category = Category::where('id', $this->category_id)->get();//через where отображаем все записи
dd($category); //распечатываем переменную
}
Так же теперь используем функцию getCategory() в шаблоне card.blade.php:
{{ $product->getCategory() }}
Через dd мы видим что передался многомерный массив (Collection - коллекция), чтобы получить только один экземпляр мы
можем использовать вместо функции get() функцию first()- так мы сразу получаем категорию, с которой удобней работать:
$category = Category::where('id', $this->category_id)->first();
На самом деле будет еще удобнее, если сменить first() на find() в которой и передадим 'category_id':
$category = Category::find($this->category_id); //результат такой же
Дальше нам нужно просто вернуть, что появилось:
return Category::find($this->category_id);
И теперь в карточке товара (шаблон card) мы можем дальше использовать ->name:
 <p>{{ $product->getCategory()->name }}</p>
 Теперь в кажом товаре на главной отображается его категория, а эту конструкцию можно удалить:
        @isset($category)
             {{ $category->name }}
        @endisset

#Дальше выводим в категории только те товары, которые относятся к этой категории(04:30). Для этого переходим в
MainController, где добавляем для метода category() переменную products(как в методе index):
public function category($code): Factory|View|Application
{
$category = Category::where('code', $code)->first();
$products = Product::get();
return view('category', compact('category', 'products'));
}
И в самом представлении категория(шаблон category) вместо строчки:
@include('card', ['category' => $category])
обрабатываем как в шаблоне index(вставляем блок):
@foreach($products as $product)
@include('card', compact('product'))
@endforeach
После этого на каждой странице категории выводятся все товары (не зависимо от категории).

#Теперь будем фильтровать(05:30). Для этого в Меинконтролере в методе продукт внесем измененияв строчке:
$products = Product::get(); //выводить все продукты
$products = Product::where('category_id', $category->id)->get();//теперь выводятся только нужные!!!

#Теперь у нас все работает, но исполняется принцип единства ответственности. Наш контроллер выходит немного
перегруженным. Чтобы этого небыло мы должны использовать связи. Для этого мы переходим в модель Product, где мы
пропишем функцию категория, которая должна вернуть только одну категорию. И так как у нас есть продукт, который
относится к категории, то мы используем belongsTo(), в которой мы указываем продукт:
public function category()
{
return $this->belongsTo(Category::class);
}
Чтобы дальше эту функцию использовать мы идем в шаблон карточки и здесь мы заменяем:
{{ $product->getCategory()->name }}
на:
{{ $product->category->name }}
Если мы захотим использовать вот таким образом:
{{ $product->category()->name }}
то это будет уже Query Builder(у меня так не сработал - ошибка)
Теперь метод getCategory() можно удалить, он не нужен.

#Дальше нам нужно добавить зависимость от категории к товарам(08:22). Для этого в классе Category создаем публичный
метод products(), в котором возвращаем функцию hasMany() - связи ко многим:
public function products()
{
return $this->hasMany(Product::class);
}
Теперь нашу связь мы можем использовать в шаблоне категория, где в цикле изменяем:
@foreach($products as $product)
на: @foreach($category->products as $product)
Так как $products мы теперь не используем, то можем из MainController из метода category строчку с переменой $products
удалить, теперь этот метод будет выглядеть так:
public function category($code): Factory|View|Application
{
$category = Category::where('code', $code)->first();
return view('category', compact('category'));
}

#Выводим подсчет количества товаров в категории(10:00) используя теже самые связи - переходим в шаблон category, где
в строчку: {{$category->name}} добавляем вызов категории с встроенной функцией count():
{{$category->name}} {{$category->products->count()}}// получаем "Мобильные телефоны 4"

#Прописываем ссылку на товар в шаблоне card. Для этого изменяем нашу ссылку:
<a href="/mobiles/iphone_x_64" class="btn btn-default" role="button">Подробнее</a>
на новый роут:
<a href="{{ route('product',[$product->category->code, $product->code]) }}"
class="btn btn-default" role="button">Подробнее</a>


Урок №6 Многие-ко-многим, Сессия
#Следующее, что нам нужно сделать - реализовать корзину и заказ. Это мы будем делать через одну модель. Создаем новый
класс Order вместе с миграцией:
sail artisan make:model -m Order

#Редактируем воля в нашей миграции: /database/migration. Нам нужен, во-первых, статус, если мы хотим совместить и заказ
и корзину в одно, то нам нужно это все указать:
            $table->tinyInteger('status')->default(0);//0 - это для незаказанных товаров.
            $table->string('name')->nullable(); //данные заказчика, необязательный параметр
            $table->string('phone')->nullable(); //данные заказчика, необязательный параметр.
Запускаем миграцию:
sail artisan migrate

#Так же нам нужна связка для понимания какие продукты лежат в нашем заказе. Для этого мы создадим еще одну миграцию:
sail artisan make:migration create_order_product_table

#В этой миграции мы добавим еще два поля(кроме стандартных):
            $table->integer('order_id');
            $table->integer('product_id');
Зачем нам такая таблица нужна? Для каждого заказа у нас может быть несколько продуктов, так же каждый продукт может
 находитиься в нескольких заказах.
 Запускаем миграцию:
 sail artisan migrate

#Почему наша новая таблица называется "order_product", а не наоборот? Мы будем использовать связь, и чтобы связь
использовала название таблицы поумолчанию нам нужно название наших сущностей order и product расположить в алфавитном
 порядке.

#Добавляем связь, чтобы из заказа найти наши продукты(03:20), для этого в классе Order добавляем метод products во
множественном числе:
    public function products()
    {
        return $this->belongsToMany(Product::class);
    }
По-идее она должна подхватить таблицу "order_product" - через 'order_id' и 'product_id' составить соотношение.

#Так же нам нужно бы уже создать новый маршрут, который будет отвечать за то, чтобы положить какой-то продукт в корзину.
Создаем новый контроллер:
    sail artisan make:controller BasketController
Убираем из MainController методы basket() и basketPlace() в новый класс BasketController.
Добавляем так же информацию в роутер web.php:
    Route::get('/basket', [MainController::class, 'basket'])->name('basket');
    Route::get('/basket/place', [MainController::class, 'basketPlace'])->name('basket-place');
меняем на:
    Route::get('/basket', [BasketController::class, 'basket'])->name('basket');
    Route::get('/basket/place', [BasketController::class, 'basketPlace'])->name('basket-place');

#Дальше нам нужно сделать маршрут, который будет отвечать за добавление товара(05:00) в web.php методом POST, так как
все что мы изменяем мы испольуем метод POST(http метод):
Route::post('/basket/add/{id}', [BasketController::class, 'basketAdd'])->name('basket-add'); //id - идентификатор продукта

#Чтобы воспользоваться этим методом мы идем в карточку товара(card) и делаем из ссылки форму:
    <form action="{{ route('basket-add', $product) }}" method="POST">...
Идентификатор у переменной продукт можно не указывать($product->id).

#Пробуем добавить товар в корзину - выдает 419 ошибку(используется в качестве альтернативы коду 401, которые прошли проверку
 подлинности, но лишены доступа к определенным ресурсам сервера. Обычно код отдается, если CSRF-токен устарел или оказался
 некорректным.). Для того, чтобы убрать эту ошибку, нужно добавить csrf-токен(под токеном имеется в виду случайный набор
 байт, который сервер передает клиенту, а клиент возвращает серверу).Чтобы его добавить мы можем воспользоваться директивой
 блейда
    @csrf
эта команда генерирует скрытый инпут со случайным токеном, такого образца:
    <input type="hidden" name="_token" value="A6RKV8btdJu2SrcengeSw9JserC4AVdI9iX0TPxS">

#Теперь нам осталось добавить еще один метод, котрый будет отвечать за добавление товаров в корзину в классе BasketController.
Для того чтобы добавлять товары нам нужна сессия - в Laravel ее создает встроенный хелпер session(). А для того, чтобы
достать что-то из сессии мы будем использовать аргумент 'orderId':
    public function basketAdd($productId)
    {
        $orderId = session('orderId');
        if (is_null($orderId)) { //если нет сессии создаем ее
            $order = Order::create()->id;
            session(['orderId' => $order->id]);
        } else {
            $order = Order::find($orderId); //если есть находим
        }
        $order->products()->attach($productId); //добавляем товар в корзину, используем нашу связь.

        return view('basket', compact('order'));
    }
Проверяем в базе товары появляются при нажатии на корзину.
Вносим изменения так же в метод basket():
    public function basket():Factory|View|Application
    {
        $orderId = session('orderId');
        if (!is_null($orderId)) {
        $order = Order::findOfFail($orderId);
        }
        return view('basket');
    }

#Теперь нам нужно перейти в представление/шаблон basket.blade.php и добавить обработку наших товаров:
    @foreach($order->products as $product)
        //сюда размещаем блок товара
    @endforeach

#В роутере web.php строчка роутером 'basket' должна быть выше расположена, чем роутер 'category'!!! Иначе ошибка.

#Добавляем роут к правильным ссылкам в корзине:
 <a href="{{ route('product', [$product->category->code, $product->code]) }}">
так же заменяем ссылку:
    /basket/add/1
на:
    <form action="{{ route('basket-add', $product) }}" method="POST">
добавляем @csrf токен


Урок №7 Pivot table
#Добавляем маршрут для удаления товаров из корзины. Добавляем роут в web.php:
Route::post('/basket/remove/{id}', [BasketController::class, 'basketRemove'])->name('basket-remove');

#Изменяем роут в basket.blade.php:
    <form action="{{ route('basket-remove', $product) }}" method="POST">
        <button type="submit" class="btn btn-danger" href=""><span
                class="glyphicon glyphicon-minus" aria-hidden="true"></span></button>
        @csrf
    </form>

#В BasketController добавляем метод удаления из корзины:
    public function basketRemove($productId):RedirectResponse
    {
        $orderId = session('orderId');
        if (is_null($orderId)) {
            return redirect()->route('basket');
        }
        $order = Order::find($orderId);
        $order->products()->detach($productId);//удалям продукт
        return redirect()->route('basket');
    }

#Чтобы при обновлении страницы не добавляло новый товар - в функцию basketAdd добавим редирект на другой маршрут:
return redirect()->route('basket');
А эту строчку удаляем:
return view('basket', compact('order'));

#Теперь нам нужно реализовать количество добавляемого товара, чтобы не новой строчкой одинаковый товар добавлялся,
а изменялась цифра-количество товаров. Для этого нам нужно добавить миграцию (добавим еще одно поле в таблицу через
update). Миграция с таким же именем уже была создана ранее, записана в таблицу и если ее откатить для внесения изменений,
то мы потеряем в таблице все наши данные.
sail artisan make:migration update_order_product_table
Далее копируем из предыдущей миграци с таким же именем поля метода up():
     Schema::table('order_product', function (Blueprint $table) { //только вместо Schema::table...
         $table->integer('count')->default(1); //добавляем новое поле
     });
И в методе down() добавляем:
    Schema::table('order_product', function (Blueprint $table) {
        $table->dropColumn('count');
    });
#Запускаем миграцию:
    sail artisan migrate
После этого замечаем, что лучше было бы указать место расположения нового поля:
    $table->integer('count')->default(1)->after('product_id');
Для внесения изменений в таблице нам придется откатить последнее изменение:
    sail artisan migrate:rollback --step=1
Затем снова миграцию делаем:
    sail artisan migrate

#Теперь нам нужно этот count заставить работать. Для этого в Order.php добавляем возможность достучаться до поля count:
    return $this->belongsToMany(Product::class)->withPivot('count');

#Теперь нужно к контиролере корзины добавить при добавлении проверку если у нас уже такой товар:
        if ($order->products->contains($productId)) {//если товар есть в корзине:
            $pivotRow = $order->products()->where('product_id', $productId)->first()->pivot;
            $pivotRow->count++;//увеличивает attributes-count на 1
            $pivotRow->update();//обновляем в БД
            dd($pivotRow);//проверка вывода
        } else {//если товара нет в корзине:
            $order->products()->attach($productId); //добавляем товар в корзину, используем нашу связь.
        }

#Теперь нам то же самое нужно проделать с удалением товара:
        if ($order->products->contains($productId)) {
            $pivotRow = $order->products()->where('product_id', $productId)->first()->pivot;
            if ($pivotRow->count < 2) { //если 1 или 0
                $order->products()->detach($productId);//удалям продукт
            } else {
                $pivotRow->count--;//уменьшаем attributes-count на 1
                $pivotRow->update();//обновляем в БД
            }
        }

#В шаблон basket добавляем отображение изменения количчества товаров (из БД) (13:15):
    {{ $product->pivot->count }}

#Добавляем общую сумму покупок. Для этого в классе Product добавляем новый метод:
    public function getPriceCount($count)
    {
        return $this->price * $count;
    }
Добавляем вывод в шаблон корзины - вместо:
    {{ $product->price }}
Пишем:
    {{ $product->getPriceCount($product->pivot->count) }}

#Добавляем подсчет стоимости всех товаров в корзине, для этого в классе Order.php добавляем метод:
    public function getFullPrice():int | float
    {
        $sum = 0;
        foreach ($this->products as $product) {
            $sum += $product->getPriceForCount();
        }
        return $sum;
    }

#Выводим общую сумму в basket.blade.php:
{{ $order->getFullPrice()}}

Урок №8 Request, Flash

#Доделываем нашу корзину заказов и делаем, чтобы заказ был полностью оформлен.

#Добавляем переход на страницу заказа. Для этого из роутера (web.php) берем basket-place и прописываем путь в basket.blade.php
вместо href="/basket/place"> прописываем  роут:
href="{{ route('basket-place') }}"

#В order.blade.php не верно выводится общая сумма - нужно поправить. Для этого переходим в BasketController и правим метод
basketPlace():
    public function basketPlace()
    {
        $orderId = session('orderId');
        if (is_null($orderId)) {
            return redirect()->route('index'); //возвращаем на главную
        }
        $order = Order::find($orderId);
        return view('order', compact('order'));
    }
И в order.blade.php добавляем общую цену:
{{ $order->getFullPrice()}} грн.

#Теперь нам нужно, чтобы эта кнопка вела туда, где будет сохранен наш заказ. В web.php добавляем еще один роут:
Route::post('/basket/place', [BasketController::class, 'basketConfirm'])->name('basket-confirm');

#В order.blade.php добавляем роут в экшин формы:
<form action="{{ route('basket-confirm') }}" method="POST">

#Добавляем @csrf токен в форму перед кнопкой

#B BasketController теперь нужно реализовать новый метод из web.php basketConfirm():
    public function basketConfirm()
    {

    }
При переходе по кнопке "Подтвердите заказ" страница одновляется, но получаем пустую страницу, так как метод еще не реализован.

#В папке с шаблонами (/resourses/views) нужно навести порядок и сложить некоторые швблоны в новую подпапку layouts,
после туда перемещаем master.blade.php, card.blade.php

#В product.blade.php так же часто повторяется блок <div class="starter-template">, поэтому мы его тоже вынесем в
master.blade.php:
    <div class="starter-template">
        @yield('content')
    </div>
И в каждом из шаблонов соответственно этот блок нужно убрать, чтобы небыло дублей.

#Добавляем логику сохранения в БД в метод basketConfirm():
    public function basketConfirm(Request $request):RedirectResponse
    {
        $orderId = session('orderId');
        if (is_null($orderId)) { //если нет сессии создаем ее
            return redirect()->route('index'); //возвращаем на главную
        }
        $order = Order::find($orderId); //если есть находим
        $order->name = $request->name;
        $order->phone = $request->phone;
        $order->status = 1; //изменяем статус в БД с 0 до 1
        $order->save();
        //dd($request->all());//выводит всю информацию о заказчике
        //dd($request->name);//выводит ФИО заказчика
        session()->forget('orderId');//убираем из сессии и передаем ключ, по которому должен забыть переменную
        return redirect()->route('index'); //возвращаем на главную
    }
Теперь если нажимаем подтвердить заказ - в таблице 'orders' у заказа появляется статус и данные о заказчике.

#Все работает, но нужна оптимизация - слишком много логики для контролера, поэтому часть кода переносим в модель
в класс Order заменив переменную $order на $this, с реквестом мы тоже тут не будем работать, поэтому в метод передадим
имя и телефон:
    public function saveOrder($name, $phone)
    {
        if ($this->status == 0) {
            $this->name = $name;
            $this->phone = $phone;
            $this->status = 1; //изменяем статус в БД с 0 до 1
            $this->save();
            session()->forget('orderId');//убираем из сессии и передаем ключ, по которому должен забыть переменную
            return true;
        } else {
            return false;
        }
    }

BasketController теперь станет немного чище:
    public function basketConfirm(Request $request):RedirectResponse
    {
        $orderId = session('orderId');
        if (is_null($orderId)) { //если нет сессии создаем ее
            return redirect()->route('index'); //возвращаем на главную
        }
        $order = Order::find($orderId); //если есть находим
        $success = $order->saveOrder($request->name, $request->phone);
        return redirect()->route('index'); //возвращаем на главную
    }

#Функционал сообщенией "Ваше товар добавлен в корзину", "Ваш заказа отправлен в обработку" реализован с помощью
 Flash(13:30). То есть это часть функционала сессии, такие переменные внутри сессии, которые после первого отображения
 позволяет их автоматически удалять. Флеш в Laravel реализован с помощью функции flash() - в BasketController добавим:
        if ($success) {
            session()->flash('success', 'Ваш заказ принят в обработку');
        } else {
            session()->flash('warning', 'Случилась ошибка');
        }

#Для отображения вывода flash добавления (зеленая расцветка)переходим в master.blade.php:
        @if(session()->has('success'))// условие для вывода flash сообщения
        <p class="alert alert-success">{{ session()->get('success') }}</p>// вывод flash сообщения
        @endif
        @yield('content')

#В BasketController в методе basketAdd() добавим отображение сообщения об добавлении товара в корзину:
        $product = Product::find($productId);//находим товар
        session()->flash('success', 'Добавлен товар '. $product->name);

#Для отображения вывода flash удаления (желтая расцветка)переходим в master.blade.php:
        @if(session()->has('warning'))
            <p class="alert alert-warning">{{ session()->get('warning') }}</p>
        @endif

#В BasketController в методе basketRemove() добавляем сообщение об удалении товара из корзины:
        $product = Product::find($productId);//находим товар
        session()->flash('warning', 'Удален товар '. $product->name);


Урок №9 Авторизация, Регистрация

#Добаление административной панели.

#В уроках используется Laravel 6 и там аутентификация встроена, для поздних версий (у меня 9я) нужно устанавливать:
composer require laravel/ui

#У меня сразу не получилось установить выдало ошибку. Помогло вот это:
    > sudo apt-get install php-curl
    > sudo apt-get install php-mbstring
#for every missing extension. Then:
    > sudo apt-get update
#and finally (in the project's root folder):
    > composer install

Дальше:
    composer require laravel/ui
    composer dump-autoload
    sail artisan optimize
    sail artisan ui:auth
Теперь в /app/Http/Controllers/Auth папка с файлами появилась, как в уроке.
Дальше создаем шаблоны авторизации:
    sail artisan ui vue --auth


#После установки в web.php появился новый роут:
    Auth::routes();
    Route::get('/home', [App\Http\Controllers\HomeController::class, 'index'])->name('home');
в web.php в самый вверх прописать:
    use Illuminate\Support\Facades\Auth;

#Чтобы посмотреть, что нового добавилось нужно ввести(покажет новые маршруты):
    sail artisan route:list

#Как посмотреть какие маршруты у нас зарегистрированы - переходим к файлу Router.php(Shift два раза кликнуть), таких
файла два, выбираем того, что для Laravel.

#В web.php добавляем строчки (обрезаем неиспользуемые параметры):
Auth::routes([
    'reset' => false,
    'confirm' => false,
    'verify' => false,
]);

#В папку /resources/view/auth добавляем файлы login.blade.php, register.blade.php, а содержание берем из html
кода оригинального сайта.

#Название для шаблонов берем из трейтов AuthenticatesUsers ('login') и RegistersUsers ('register')

#Добавляем /layouts/master.blade.php  - шаблон для аутентификации, чтобы не повторялись поля в коде.
меняем: <title>Админка: Регистрация</title>
на: <title>Админка: @yield('title')</title>
меняем: <div class="card-header">Регистрация</div>
на: @yield('title')
Удаляем уникальные для разных страниц блоки, остается общий шаблон. Вместо уникального контента пишем:
@yield('content')

#В login.blade.php, register.blade.php оставляем только уникальный контент между скриптом:
@extends('auth.layouts.master')//расположение master шаблона
@section('title', 'Авторизация')//или 'Регистрация'
    @section('content')
        //форма регистрации/логина
    @endsection

#Добавляем роуты в master.blade.php:
<a class="nav-link" href="{{ route('login') }}">Войти</a>
<a class="nav-link" href="{{ route('register') }}">Зарегистрироваться</a>

В шаблон register:
<form method="POST" action="{{ route('register') }}" aria-label="Register">

#В роутер добавляем :
    use App\Http\Controllers\Auth\LoginController;
прописываем путь и назначаем имя как будем называть:
    Route::get('/logout', [LoginController::class, 'logout'])->name('get-logout');

#В основной мастер шаблон добавляем в верхнее меню ссылку входа/выхода:
    @guest()
        <li><a href="{{ route('login') }}">Панель администратора</a></li>
    @endguest
    @auth()
            <li><a href="{{ route('home') }}">Панель администратора</a></li>
        <li><a href="{{ route('get-logout') }}">Выйти</a></li>
    @endauth

#Добавим новый контроллер(12:20): //он у нас уже создался ранее
sail artisan make:Controller HomeController

#B web.php добавляем маршрут:
Route::get('/home', [HomeController::class, 'index'])->name('home');


Урок №10 Middleware Авторизации

#web.php добавляем middleware(это прослойка между маршрутом и контроллером)
Route::get('/home', [HomeController::class, 'index'])->name('home')->middleware('auth');

#Для каждого маршрута добавлять проверку не очень удобно, поэтому есть способ через Route::group
Route::group(['middleware' => 'auth'], function () {
    Route::get('/home', [HomeController::class, 'index'])->name('home');
});

#Добавляем страницу заказов в админке - создаем шаблон resources/viewes/auth/orders/index.blade.php
ДОбавляем уникальный html код. Добавляем функционал из мастершаблона.

#B HomeController добавляем маршрут к админке:
class HomeController extends Controller
{
    public function index():Factory|View|Application
    {
        return view('auth.orders.index');
    }
}

#Правим наш register.blade.php, master.blade.php

#B web.php /home меняем на /orders

#HomeController меняем на OrderController через Shift+F6 (после чего везде меняется название)

#Добавляем новый метод в LoginController:
    protected function redirectTo():string
    {
        return route('home');
    }

#Проверка роута: (15:30)
php artisan route:list
Смотрим, что register осуществляет POST Auth\RegisterController@register, переходим в него и видим там свойство $redirectTo
Добавляем в этом контролере новый метод с таким же названием redirectTo():
    protected function redirectTo()
    {
        return route('home');
    }
А protected $redirectTo = RouteServiceProvider::HOME; удаляем

#OrderController.php переносим в новосозданную папку Admin, так как так логичнее. После переноса проверяем, чтобы в
неймспейсах прописалась новая папка. Так же проверяем, чтобы неймспес сменился у этого контролера и в web.php
В метод index добавляем строку:
        $orders = Order::where('status', 1)->get();
        return view('auth.orders.index', compact('orders'));

B index.blade.php отображаем:
            @foreach($orders as $order)
                <tr>
                    <td>{{ $order->id}}</td>
                    <td>{{ $order->name }}</td>
                    <td>{{ $order->phone }}</td>
                    <td>{{ $order->created_at->format('H:i d/m/Y') }}</td>
                    <td>{{ $order->getFullPrice() }} грн.</td>
                    <td>
                        <div class="btn-group" role="group">
                            <a class="btn btn-success" type="button"
                               href="http://laravel-diplom-1.rdavydov.ru/admin/orders/1">Открыть</a>
                        </div>
                    </td>
                </tr>
            @endforeach


#

Урок №11 Создание Middleware, Auth

#На данный момент в админке у нас любой зарегистрировавшийся пользователь может попасть в админку и видеть все заказы.
Для этого мы создадим новое поле в таблице 'users':
sail artisan make:migration alter_table_users

#В новой миграции добавляем поле 'is_admin'. Методы копируем из предыдущей миграции, меняем только название таблицы,
 название и свойства полей:
    public function up():void
    {
        Schema::table('users', function (Blueprint $table) {
            $table->tinyInteger('is_admin')->default(0);
        });
    }
    public function down():void //это метод для отката миграции
    {
        Schema::table('users', function (Blueprint $table) {
            $table->dropColumn('is_admin');
        });
    }
Запускаем миграцию:
    sail artisan migrate

#Переходим в талицу и в поле 'is_admin' вручную добавляем "1" тем email, кого хотим видеть адимнистратором.

#Теперь нам нужно это как-то проверять и фильтровать. Для этого добавим Middleware. Делаем через:
    sail artisan make:
появляется подсказка и оттуда подсматриваем + добавляем название и запускаем:
    sail artisan make:middleware ChackIsAdmin
У нас появился новый класс ChackIsAdmin
    public function handle(Request $request, Closure $next)
    {
        return $next($request);
    }
Модифицируем его - если пользователь не админ, то он должен редиректиться на главную страницу. Для этого нам нужно создать
новую функцию в классе User:
    public function isAdmin()
    {
        return $this->is_admin === 1;
    }

#В Kernel.php добавляем
protected $routeMiddleware = [
...
        'is_admin' => \App\Http\Middleware\ChackIsAdmin::class,

Дальше нам нужно вот этот алиас использовать внутри роутинга(web.php):
вместо :
    Route::get('/orders', [OrderController::class, 'index'])->name('home');
прописываем:
    Route::group(['middleware' => 'is_admin'], function () {
        Route::get('/orders', [OrderController::class, 'index'])->name('home');
    });

#Теперь в ChackIsAdmin проверим что мы туда попадаем добавив: dd(1);
Должно вывести 1 при переходе в /routers, но у меня ничего не произошло, поэтому чистим кеш:
    sail artisan route:cache
Теперь все работает. Вместо dd добавляем фасад Auth и берем функцию user. Фасад - это некий статичный класс, который
закрывает наш функционал.
    public function handle(Request $request, Closure $next)
    {
        $user = Auth::user();
        dd($user);
        return $next($request);
    }
У нас появился объект модели user с полем 'is_admin', но тут много ненужной информации ищем только это:
     dd($user->isAdmin());
Получаем true/false. Все работает, поэтому вместо dd прописываем условие:
        if(!$user->isAdmin()){
            session()->flash('warning', 'У вас нет прав администратора'); //уведомление
            return redirect()->route('index'); //редирект если не админ на главную
        }
Меняем в БД себе права с 1 на 0 и пробуем зайти на /orders - перебрасывает на главную, все работает.

#Теперь добавить возможность отображения по кажому пользователю какие заказы он в прошлом заказывал. Для этого в таблице
'orders' добавить новое поле 'user_id':
    sail artisan make:migration alter_table_orders
Добавляем методы:
    public function up()
    {
        Schema::table('orders', function (Blueprint $table) {
            $table->integer('user_id');//по умолчанию у нас все поля not nullable
        });
    }
    public function down()
    {
        Schema::table('orders', function (Blueprint $table) {
            $table->dropColumn('user_id');
        });
    }
Запускаем миграцию:
    sail artisan migrate

#B BasketController добавляем передачу заказа в новое поле в методе basketAd():
        if (Auth::check()) {//если мы авторизованы, то:
            $order->user_id = Auth::id();//добавляем в поле 'user_id' метод id() класса Auth
            $order->save(); // сохраняем
        }

#При создани миграции мы не указали, что если пользователь если не авторизован, то у него "0". Для этого откатываем нашу
миграцию(если мы эту миграцию никуда не пушили, то можно просто менять):
    sail artisan migrate:rollback --step=1
Добавляем nullable:
    public function up()
    {
        Schema::table('orders', function (Blueprint $table) {
            $table->integer('user_id')->nullable();//по умолчанию у нас все поля not nullable
        });
    }
Затем снова делаем миграцию:
    sail artisan migrate
И пробуем добавить в корзину товар. В таблице 'orders' появилось поле 'user_id' и в нем уже проставляется id пользователя,
заказавшего этот товар.

#Теперь нужно реализовать выход из корзины, если покупатель удалил свой товар и корзина пустая, а так же сделать
не возможным заходить в пустую корзину. Это опять же мы реализуем через middleware:
    sail artisan make:middleware BasketIsNotEmpty

затем мы этот класс регистрируем в Kernel.php:
        'basket_not_empty' => \App\Http\Middleware\BasketIsNotEmpty::class,

Теперь этот middleware нужно повесить на все маршруты, которые работают с корзиной(в web.php), для этого создаем роут
и переносим в него все ранее созданные роуты, которые уже работают с корзиной:
    Route::group(['middleware' => 'basket_not_empty'], function () {
        Route::get('/basket', [BasketController::class, 'basket'])->name('basket');
        Route::get('/basket/place', [BasketController::class, 'basketPlace'])->name('basket-place');
        Route::post('/basket/add/{id}', [BasketController::class, 'basketAdd'])->name('basket-add');
        Route::post('/basket/remove/{id}', [BasketController::class, 'basketRemove'])->name('basket-remove');
        Route::post('/basket/place', [BasketController::class, 'basketConfirm'])->name('basket-confirm');
    });

Так же мы видим, что везде в роутах повторяется слово basket, поэтому мы его перенесем в group(кроме "basket-add"):
Route::group([
    'middleware' => 'basket_not_empty',
    'prefix' => 'basket',//по умолчанию добавляет слово basket, теперь слово basket из роута можно удалить
], function () {
    Route::get('/', [BasketController::class, 'basket'])->name('basket');
    Route::get('/place', [BasketController::class, 'basketPlace'])->name('basket-place');

    Route::post('/remove/{id}', [BasketController::class, 'basketRemove'])->name('basket-remove');
    Route::post('/place', [BasketController::class, 'basketConfirm'])->name('basket-confirm');
});
Route::post('/basket/add/{id}', [BasketController::class, 'basketAdd'])->name('basket-add');
Так же повторяется название, но мы его пока не будем выносить.
Проверяем - выходим и заходим в пустую корзину, все работает как ранее, значит ничего не сломалось хотя бы.

#Проверить если в нас заказ? Для этого переходим в BasketController, копируем проверку и вставляем в BasketIsNotEmpty
и меняем значение на !is_null:
        $orderId = session('orderId');
        if (!is_null($orderId)) {
            $order = Order::findOrFail($orderId);//выдаст 404 ошибку, если по id Oder ничего не будет найдено
            if ($order->products->count() === 0) {//если количество товаров 0, то редиректим назад
                session()->flash('warning', 'Ваша корзина пуста');
                return redirect()->route('index');
            }
        }



Урок №12: Resource Controller, REST, Spoofing

#В Laravel есть понятие ресурс-контроллера, для его создания запускаем команду:
sail artisan make:controller Admin/CategoryController --resource

Но есть еще более удобный вариант:
sail artisan make:controller Admin/CategoryController --resource --model=Category
так Laravel находит модель и подставляет к каждому методу. В результате в каждый метод было прокинуто свойство $category

#Регистрируем все эти маршруты в web.php:
Route::resource('categories', 'CategoryController');

В метод group добавляем префиксы для URI:
'prefix'     => 'admin',

#Проверяем роуты:
sail artisan route:list

#B master.blade.php избавляемся от старых ссылок:
<li><a href="/admin/categories">Категории</a></li>
меняем на:
<li><a href="{{ route('categories.index') }}">Категории</a></li>
и так далее.

#Создаем новый шаблон:
resources/views/auth/categories/index.blade.php

#В CategoryController в метод index() добавляем:
    return view('auth.categories.index');

#Появилась ошибка - не видит класс "Target class [Admin\CategoryController] does not exist."
Почистил кеш - не помогло:
    sail artisan route:cache
    sail artisan route:clear

Перегрузил автозагрузку - тоже не помогло:
    composer dump-autoload

Сделал проверку роутлиста:
    sail artisan route:list
Пишет, что "Class "Admin\CategoryController" does not exist"

Почитал документацию там класс по другому пишут в роутах(https://laravel.com/docs/9.x/controllers):
    Route::resource('categories', CategoryController::class);
Но тоже не помогло, хотя класс импортировал.

Помогло убрать неймспейсы в web.php:
Route::group([
    'middleware' => 'auth',
   // 'namespace'  => 'Admin',
    'prefix'     => 'admin',

# В ходе урока по дизайне-паттерну Rest мы сделали возможным редактировать наши категории


Урок №13 Storage

#По аналогии с прошлым уроком создаем возможность просматривать, редактировать и удалять товары.
Для этого создаем новый контроллер ProductController.
Добавляем в класс Product:
    protected $fillable = ['name', 'code', 'price', 'category_id', 'description', 'image'];
Добавляем шаблоны:
    resources/views/auth/products/form.blade.php
    resources/views/auth/products/index.blade.php
    resources/views/auth/products/show.blade.php
В существующий master.blade.php добавляем роуты:
    <li><a href="{{ route('products.index') }}">Товары</a>
    <li><a href="{{ route('home') }}">Заказы</a></li>
В web.php новый роут(импортируем класс):
    Route::resource('products', ProductController::class);

#Теперь в админке "Товары" открываются и их можно редактировать и удалять, а "Заказы" выводятся, но просматривать еще нельзя.

# При редактировании товаров добавляем динамичности в выборе категории - в ProductController добавляем:
    public function create():View|Factory|Application
    {
        $categories = Category::get();
        return view('auth.products.form', compact('categories'));
    }
    public function edit(Product $product):View|Factory|Application
    {
        $categories = Category::get();
        return view('auth.products.form', compact('product', 'categories'));
    }
Затем в form.blade через цикл выводим выпадающий список:
Вместо:
        <select name="category_id" id="category_id" class="form-control">
            <option value="1">Мобильные телефоны</option>
            <option value="2">Портативная техника</option>
            <option value="3">Бытовая техника</option>
        </select>
Добавляем:
        @foreach($categories as $category)
           <option value="{{ $category->id }}"> {{ $category->name }} </option>
        @endforeach
Вывод уже работает, но нужнго проверить еще и на существование категории:
          @foreach($categories as $category)
            <option value="{{ $category->id }}"
            @isset($product)
                @if($product->category_id == $category->id)
                    selected
                    @endif
                @endisset
            > {{ $category->name }} </option>
            @endforeach

#Следующий этам - добавление картинки в категорию. Laravel работает со всеми файловыми хранилищами через абстрактный
 класс - фасад Storage. Настроим Storage. Сам класс в папке /storage/app/public. В config/filesystems.php настройки.
 Если выбрать 'disks' => 'public', то будут видны все файлы, которые на сервер к себе загружаете в storage. По умолчанию
 корневая директория root является public, поэтому что-бы попасть в storage в Laravel есть возможность через команду
 артисан создать семлинк:
    sail artisan storage:link
// INFO  The [public/storage] link has been connected to [storage/app/public]. //в паблик папке сделали файлик storage.
Далее переходим в CategoryController в методе store нам нужно получить путь к новому созданному файлу:
    public function store(Request $request):RedirectResponse
    {
        $path = $request->file('image')->store('categories');
        //image - название поля html верстке в input у кнопки "Загрузить", categories - папка для загрузки картинок
        $params = $request->all();
        $params['image'] = $path;
        Category::create($params);
        return redirect()->route('categories.index');
    }
Далее пробуем создать новую категорию и прикрепить к ней картинку, затем переходим в БД и можем видеть в поле таблице
"categories" в поле "image" появилась надпись с путем к файлу.
Появилась новая папка: /storage/app/categories/
Чтобы отображались картинки в public нужно в .env меняем:
FILESYSTEM_DISK=local на FILESYSTEM_DISK=public
//в уроке добавлялся файл FILESYSTEM_DRIVER=public, так как такой путь был в filesystems.php

#Для добавления возможности перезаписи изображения добавляем в CategoryController в метод update логику из store,
код такой же, только добавляем сначала удаляем предыдущую с помощью метода фасада Storage::delete:
        Storage::delete('image');//в старых версиях так писать: Storage::delete($product->image);
        $path = $request->file('image')->store('categories');
        $params = $request->all();
        $params['image'] = $path;
        Category::create($params);
        $category->update($params);
        return redirect()->route('categories.index');

#Дублируем так же для метода store у ProductController такой же код:
        $path = $request->file('image')->store('products');
        $params = $request->all();
        $params['image'] = $path;
        Product::create($params);
        return redirect()->route('products.index');
и в методе update:
        Storage::delete('image');// в старых версиях так писать: Storage::delete($product->image);
        $path = $request->file('image')->store('products');
        $params = $request->all();
        $params['image'] = $path;
        $product->update($params);
        return redirect()->route('products.index');

#И соответствено вносим изменения в /products/show.blade.php - там где "Картинки":
    <td><img src="{{ Storage::url($product->image) }}" height="240px"></td>

#Проверяем - у новых товаров изображения тоже добавляются.

#Теперь нужно изменить вывод изображения товаров на главной странице. Для этого переходим в /layouts/card.blade.php
вместо:
<img src="http://internet-shop.tmweb.ru/storage/products/iphone_x.jpg" alt="iPhone X 64GB">
прописываем:
<img src="{{ Storage::url($product->image) }}" alt="iPhone X 64GB">

Так же меняем ссылку и в categories.blade.php
 <img src="{{ Storage::url($category->image) }}">

Меняем так же изображение добавленное в корзину basket.blade.php:
<img height="56px" src="{{ Storage::url($product->image) }}">


Урок №14: Валидация, FormRequest

#Если пользователь забудет заполнить какое-то поле формы, то выдаст Laravel ошибку, что нам не нужно:
    Call to a member function store() on null
поэтому нам нужно сделать проверку полей - валидацию.
Для этого в метод store() CategoryController и добавляем validate метод реквеста:
    public function store(Request $request):RedirectResponse
    {
        $request->validate([
            'code'        => 'required', //required - означает, что поле обязательно для заполнения
            'name'        => 'required',
            'description' => 'required',
        ]);
        $params = $request->all();
        unset($params['image']);
        if ($request->has('image')) {//если в запросе есть картинка, то мы добавляем сохранение
            $path = $request->file('image')->store('categories');
            //image - название поля html верстке в input у кнопки "Загрузить", categories - папка для загрузки картинок
            $params['image'] = $path;
        }
        Category::create($params);
        return redirect()->route('categories.index');
    }

#Теперь при отправке пустых полей ошибка не появляется. Осталось добавить уведомление для пользователя. Переходим в
шаблон form.blade.php добавляем директиву @error, которая позволяет обработать ошибку.
Для полей 'code', 'name' и 'description'добавляем вывод ошибок (для каждого поля свою, со названием поля):
    @error('code')
        <div class="alert alert-danger">{{ $message }}</div>
    @enderror

#Правила валидации можно посомтреть тут: https://laravel.com/docs/9.x/validation#available-validation-rules

#Также нужно в CategoryController добавить такую же логику для метода update()
Нам придется вставить такой же код, как в методе store(), а это нарушает принцип единства ответственности.
Поэтому, чтобы описать валидацию нам нужно создать новый класс Request:
    sail artisan make:request CategoryRequest
Создался файл: app/Http/Requests/CategoryRequest.php
Теперь нам нужно этот класс инжектить в CategoryController вместо класса Request в методах store() и update()
Дальше нам нужно все правила перенести в CategoryRequest (из CategoryController удаляем):
    public function rules()
    {
        return [
            'code'        => 'required', //required - означает, что поле обязательно для заполнения
            'name'        => 'required',
            'description' => 'required',
        ];
    }

В методе authorize() меняем возврат с false на true - теперь вывод уведомления о пустом поле работает

#Добавляем валидацию: минимальное и максимальное количество символов в поле, а так же проверку на уникальность в таблице
'categories' в поле 'code' - при внесении такого же названия выдаст ошибку
        $rules = [
            'code' => 'required|min:3|max:255|unique:categories,code',
            'name' => 'required|min:3|max:255',
            'description' => 'required|min:5',//required - означает, что поле обязательно для заполнения
        ];

#По умолчанию все ошибки выводит на английском. Для перевода добавляем еще один метод:
    public function messages()
    {
        return [
            'required' => 'Поле :attribute обязательно для ввода', //attribute указывает название поля на англ
            'min' => 'Поле :attribute должно иметь минимум :min символов',
            'code.min' => 'Поле код должно содержать не менее :min символов', //переводит слово 'code' в 'код'
        ];
    }

#Так же по аналогии для ProductController добавляем ProductRequest:
    sail artisan make:request ProductRequest

#В ProductController меняем класс Request на ProductRequest в store() и update()

#В ProductRequest добавляем валидацию:
    public function rules()
    {
        return [
            'code' => 'required|min:3|max:255|unique:products,code',
            'name' => 'required|min:3|max:255',
            'description' => 'required|min:5',
            'price' => 'required|numeric|min:1' //numeric - значит не один символ, а одно значение
        ];

#В CategoryController добавляем проверку на существование картинки:
    public function update(CategoryRequest $request, Category $category):RedirectResponse
    {
        $params = $request->all();
        unset($params['image']);
        if ($request->has('image')) { //проверка на существование картинки
            Storage::delete('image');
            $path = $request->file('image')->store('categories');
            $params['image'] = $path;
        }
        $category->update($params);
        return redirect()->route('categories.index');
    }

#В CategoryRequest в методе rules () вместо возврата массив назначаем на переменную, чтобы дальше с ним работать.
Для визуального отображения заходим в админку, выбираем категорию, редактировать и сохраняем, затем через dd()
просматриваем что вышло:
    public function rules()
    {
        $rules = [
            'code' => 'required|min:3|max:255|unique:categories,code',
            'name' => 'required|min:3|max:255',
            'description' => 'required|min:5', //required - означает, что поле обязательно для заполнения
        ];
        //dd($rules); //распечатает наш массив
        //dd($this);//куча информации по этому классу
        //dd($this->route());//инфа по методу Route
        //dd(get_class_methods($this->route())); //встроенная функция php - просмотр какие методы у класса имеются
        //здесь есть методе named() - отображает то, что мы передали в аргумент
        // dd($this->route()->named('categories.store '));//для редактирования выдает false, для нового true
        if($this->route()->named('categories.store ')){//categories.store берем из 'sail artisan route:list'
            $rules['code'] .= '|unique:categories,code';
        }
        return $rules;
    }

#Если нужно повторно внести в форму какие-то данные то нужно в form.blade.php заменить
    value="@isset($category){{ $category->code }}@endisset">
на:
    value="{{ old('code', isset($category) ? $category->code : null) }}">

#Немного модифиииицируем наш метод В CategoryRequest в методе rules ():
    public function rules()
    {
        $rules = [
            'code' => 'required|min:3|max:255|unique:categories,code',
            'name' => 'required|min:3|max:255',
            'description' => 'required|min:5', //required - означает, что поле обязательно для заполнения
        ];
        if($this->route()->named('categories.update ')){
            $rules['code'] .= ',' . $this->route()->parameter('category')->id;
        }
        return $rules;
    }


Урок №15: Blade Custom Directive

#В этом уроке будем реализовывать подсветку пунктов меню и реализуем страничку заказов.
Для этого нам нужен /layouts/master.blade.php - это всего лишь класс active, который проставлен только для index:
     <li class="active"><a href="{{ route('index') }}">Все товары</a></li>
для остальных не проставлен. Для того чтобы реализовать, чтобы включалось только когда нужно, то нам нужно добавить
директиву @if и @endif:
    <li @if(Route::currentRouteNamed('index')) class="active" @endif><a href="{{ route('index') }}">Все товары</a></li>
    <li @if(Route::currentRouteNamed('categor*')) class="active" @endif><a href="{{ route('categories') }}">Категории</a></li>
Так можно все товары проставлять, но так будет слишком много php кода в blade. Чтобы это сделать нужно понять как
 генерируются blades. Переходим в /storage/framework/views/ и тут мы види кучу сгенерированных страниц для отображения.
 Для их очистки нужно ввести команду:
    sail artisan view:clear
Все файлы шаблонов пропали и теперь при первой загрузке страницы у нас появится скомпелированный шаблон, даже три. Находим
нужный нам файл - в нем тот же master.blade, только вместо кодов Laravel чистый php.
Переделываем код, напишем свою директиву, которая будет проверять - если роут активный, то она добавляет класс active.
Если не активный, то соотвественно ничего не добавляет.
Для этого мы переходим в AppServiceProvider здесь в методе boot() дописываем расширение для blade
    public function boot()
    {
        Blade::directive('routeactive', function ($route) {
            return "<?php echo Route::currentRouteNamed($route) ? 'class=\"active\"' : '' ?>";
        });
    }
'routeactive' - название директивы, сами придумываем, вторым аргументом будет функция замыкания, в которой
параметром $route будем передевать название роута, чтобы знать какой роут сюда попадает. В этой функции мы будем
возвращать php код
тут:  Route::currentRouteNamed($route) ? 'class=\"active\"' : '' //из master.blade взято

Теперь переходим в /layouts/master.blade.php и вместо условий @if проставляем @routeactive:
    <li @routeactive('index')><a href="{{ route('index') }}">Все товары</a></li>

 Повторно очищаем сгенерированные с шаблонов файлы иначе будет отображать ошибку синтаксиса!!!:
    sail artisan view:clear
Все работает, проделываем то же и для остальных категорий в шаблоне.
PhpStorm не понимает, что это директива blade, как с этим бороться? В IDE заходим в File->Settings->PHP->Blade->
убираем галочку 'use defalt settings' и в вкладке Directives добавляем свою директиву:
    Name: routeactive и подтверждаем. Теперь IDE подсвечивает правильно.

#Изменяем вывод о количестве товаров в корзине (если пустая), для этого переходим в BasketIsNotEmpty:
    public function handle(Request $request, Closure $next):Response|RedirectResponse
    {
        $orderId = session('orderId');
        if (!is_null($orderId)) {
            $order = Order::findOrFail($orderId);
            if ($order->products->count() > 0) {
                return $next($request);
            }
        }
        session()->flash('warning', 'Ваша корзина пуста');
        return redirect()->route('index');
    }
Теперь если товаров нет, то при клике на корзину появляется уведомление, что корзина пуста

#Реализация обработки заказов (08:20).
При заходе в "Панель администратора" попадаем на вкладку /orders ("Заказы"). Если нажать на кнопку "Открыть" у любого
заказа, то дальше функционал не реализован. Создаем новый шаблон:
    resources/views/auth/orders/show.blade.php
Добавляем из index.blade то, что будет повторяться

Теперь это нужно реализовать. Для этого переходим в /Admin/OrderController здесь нам нужно добавить метод show()
    public function show(Order $order):View|Factory|RedirectResponse|Application
    {
        return view('auth.orders.show', compact('order'));
    }

Осталось добавить в web.php маршруты:
Route::get('/orders/{order}', [OrderController::class, 'show'])->name('orders.show');

Делаем проверку:
    sail artisan route:list
Если роута 'orders.show' нет, то делаем чистку роутов:
    sail artisan route:clear
После чего проверяем повторно проверку роутов.

Так же orders/index.blade.php прописываем роут 'orders.show' и вторым параметором передаем сам заказ $order для кнопки "Открыть":
    href="{{ route('orders.show', $order) }}">Открыть</a>
Проверяем в "Заказы" кнопку "Открыть"


#Теперь реализуем возможность пользователя посмотреть свои заказы в панели администратора. Для этого создадим
новый контроллер: app/Http/Controllers/Person/OrderController.php
    sail artisan make:controller Person/OrderController

#Дальше в web.php мы должны его добавить. Давайте выделим auth middlewere, что у нас везде нужна проверка на авторизацию:
Route::middleware(['auth'])-> group(function (){
    Route::group([
        'prefix' => 'person',
        'namespace' => 'Person',
        'as' => 'person.',
    ], function () {
        Route::get('/orders', [OrderController::class, 'index'])->name('orders.index');
        Route::get('/orders/{order}', [OrderController::class, 'show'])->name('orders.show');
    });

    Route::group([
        'namespace'  => 'Admin',
        'prefix'     => 'admin',
    ], static function () {
        Route::group(['middleware' => 'is_admin'], static function () {
            Route::get('/orders', [OrderController::class, 'index'])->name('home');
            Route::get('/orders/{order}', [OrderController::class, 'show'])->name('orders.show');
        });

        Route::resource('categories', CategoryController::class);
        Route::resource('products', ProductController::class);
    });
});

#Добавим в Person/OrderController методы из Admin/OrderController копируем/импорт

#Дальше нужно попробовать пустить пользователя на нужный маршрут в loyouts/master.blade.php добавляем условие для
тех, кто прошел аутентификацию:
    @guest()
        <li><a href="{{ route('login') }}">Войти</a></li>
    @endguest
    @auth()
        @if(Auth::user()->isAdmin())
                <li><a href="{{ route('home') }}">Панель администратора</a></li>
            @else
                <li><a href="{{ route('person.orders.index') }}">Мои заказы</a></li>
            @endif

            <li><a href="{{ route('get-logout') }}">Выйти</a></li>
        @endauth

В Person/OrderController изменяем возможность видеть не все товары, а только те, чтьо принадлежат пользователю:
    public function index():Factory|View|Application
    {
        $orders = Auth::user()->orders()->where('status', 1)->get();
        return view('auth.orders.index', compact('orders'));
    }

Теперь в User нужно добавить метод orders() на который мы ссылаемся в Person/OrderController:
    public function orders()
    {
        return $this->hasMany(Order::class);
    }

Далее в orders/index.blade.php добавляем функционал из master.blade:
   <a class="btn btn-success" type="button"
       @if(Auth::user()->isAdmin())
           href="{{ route('orders.show', $order) }}"
       @else
           href="{{ route('person.orders.show', $order) }}"
        @endif
    >Открыть</a>

Теперь нам нужно сделать, чтобы небыло возможность в адресной строке путем изменения номера заказа пользовыателю
переходить на заказы других пользователей. Для этого достаточно в Person/OrderController в методе show() добавить:
    public function show(Order $order):View|Factory|RedirectResponse|Application
    {
        if (!Auth::user()->orders->contains($order)) {
            return back();
        }
        return view('auth.orders.show', compact('order'));
    }

#У нас не очень удобно получается, что в шаблоне вместо того, чтобы использовать какие-то директивы мы используем уже
 код php. Для этого лучше в AppServiceProvider добавить кастомный if(23:20) в методе boot():
        Blade::if('admin', function () {//admin - название директивы
            return Auth::check() && Auth::user()->isAdmin();
        });

Теперь в orders/index.blade.php:
    @if(Auth::user()->isAdmin())
заменяем на:
    @admin
а @endif заменяем на @endadmin

Чтобы PHPStorm нормально мог понимать эти директивы снова добавляем их в настройки и добавляем в шаблоны Blade
 директивы admin и endadmin.

#Не забываем сбрасывать кеш:
    sail artisan view:clear

#При заходе за обычного пользователя как определить куда редиректит? Нажимаем просмотр кода ПКМ, вкладка Network, далее
видим что сначала первая ссылка "Login": Request URL: http://localhost/login, Status Code: 302 Found,
дальше "orders": Request URL: http://localhost/admin/orders, Status Code: 302 Found,
и только потом "localhost": Request URL: http://localhost/, Status Code: 200 OK

#Переходим в Http/Auth/LoginController.php в метод redirectTo() здесь редиректит на "home":
    return route('home');
меняем:
    protected function redirectTo():string
    {
        if (Auth::user()->isAdmin()) {
            return route('home');
        } else {
            return route('person.orders.index');
        }
    }
Теперь если заходит "не админ", то отправляет на его заказы после авторизации.

Так же в RegisterController импортируем в метод redirectTo() вместо return route('home') новый код:
    protected function redirectTo()
    {
        if (Auth::user()->isAdmin()) {
            return route('home');
        } else {
            return route('person.orders.index');
        }
    }

В мастерюблейд исправляем:
    @guest
        <li><a href="{{ route('login') }}">Войти</a></li>
    @endguest
    @auth
        @admin
        <li><a href="{{ route('home') }}">Панель администратора</a></li>
    @else
        <li><a href="{{ route('person.orders.index') }}">Мои заказы</a></li>
        @endadmin
        <li><a href="{{ route('get-logout') }}">Выйти</a></li>
    @endauth

В ауз/мастерюблейд исправляем:
     @admin
        <li><a href="{{ route('categories.index') }}">Категории</a></li>
        <li><a href="{{ route('products.index') }}">Товары</a></li>
        <li><a href="{{ route('home') }}">Заказы</a></li>
        @else
            @endadmin



Урок №16: Seeder, Bonus!

#Для создания сидеров создаем класс, которрый будет создавать пользователей:
    sail artisan make:seeder UsersTableSeeder
В новом файле заполняем метод run():
        DB::table('users')->insert([
            'name' => 'Администратор',
            'email' => 'admin@example.com',
            'password' => bcrypt('admin'),
            'is_admin' => 1,
        ]);

В файле DatabaseSeeder добавляем в метод run():
    $this->call(UsersTableSeeder::class);

Теперь для того, чтобы запустить мы можем использовать команду запуска:
    sail artisan db:seed

В таблице "users" добавился новый пользователь "Администратор"

#Создаем сиды для категории и продуктов:
    sail artisan make:seeder CategoriesTableSeeder
В новом файле наполняем категориями и описанием (в массиве!).

#Для проверки работы нам нужно сбросить БД:
TRUNCATE laravel1.categories

Запускаем только последний seed:
    sail artisan db:seed --class=CategoriesTableSeeder

#То же самое делаем с продуктами:
    sail artisan make:seeder ProductsTableSeeder

наполняем новый сидер товарами.

#Теперь осталось реализовать "сбросить проект в начальное состояние", чтобы очищать БД
Создадим новый контроллер ResetController:
    sail artisan make:controller ResetController

Регистрируем новый маршрут в web.php:

#Запустить все сиды так же можно командой:
    sail artisan migrate:fresh --seed
Аналогично можно вызвать в методе:
    Artisan::call('migrate:fresh --seed');

#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
